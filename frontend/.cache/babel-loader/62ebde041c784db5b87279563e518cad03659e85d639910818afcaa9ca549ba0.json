{"ast":null,"code":"import axios from 'axios';\n\n// Create an axios instance with the base URL\nconst api = axios.create({\n  baseURL: 'http://localhost:8000',\n  // Updated to correct backend URL\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Request interceptor - adds auth token if available\napi.interceptors.request.use(config => {\n  // Get token from localStorage\n  const token = localStorage.getItem('token');\n\n  // Check if token exists\n  if (token) {\n    console.log(`API Request: Using token for ${config.url}`);\n\n    // JWT tokens should use Bearer prefix, not Token\n    config.headers.Authorization = `Bearer ${token}`;\n\n    // Debugging log\n    console.log('Authorization header:', config.headers.Authorization.substring(0, 15) + '...');\n  } else {\n    console.log('API Request: No token found');\n  }\n  return config;\n}, error => {\n  console.error('Request interceptor error:', error);\n  return Promise.reject(error);\n});\n\n// Response interceptor - handles auth errors\napi.interceptors.response.use(response => {\n  return response;\n}, error => {\n  // Handle 401 Unauthorized errors\n  if (error.response && error.response.status === 401) {\n    console.error('401 Unauthorized error from API:', {\n      url: error.config.url,\n      method: error.config.method,\n      headers: error.config.headers.Authorization ? error.config.headers.Authorization.substring(0, 15) + '...' : 'none'\n    });\n  }\n  return Promise.reject(error);\n});\n\n// Auth functions\nexport const loginUser = async credentials => {\n  try {\n    console.log('API: Sending login request with:', credentials.email);\n    const response = await api.post('/api/auth/login/', credentials);\n    console.log('API: Login response status:', response.status);\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    console.error('API: Login error:', error.message);\n    if (error.response) {\n      console.error('API: Server response:', error.response.data);\n    }\n    throw new Error(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Login failed. Please try again.');\n  }\n};\nexport const signupUser = async userData => {\n  try {\n    const response = await api.post('/api/auth/signup/', userData);\n    return response.data;\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n    console.error('API: Signup error:', error.message);\n    throw new Error(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Signup failed. Please try again.');\n  }\n};\n\n// User profile\nexport const getUserProfile = async () => {\n  // Use fetch API directly for better control\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) {\n      console.error('API: Cannot fetch profile - No token available');\n      throw new Error('Authentication required');\n    }\n    console.log('API: Fetching user profile with token');\n\n    // Use Bearer format for JWT tokens\n    const headers = {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    };\n    console.log('Profile request headers:', {\n      Authorization: headers.Authorization.substring(0, 15) + '...'\n    });\n\n    // Updated URL to match the backend path\n    const response = await fetch('http://localhost:8000/api/auth/profile/', {\n      method: 'GET',\n      headers: headers\n    });\n\n    // Log response status\n    console.log('API: Profile fetch response status:', response.status);\n    if (!response.ok) {\n      console.error('API: Profile fetch failed:', response.status, response.statusText);\n\n      // Return a basic user object if profile fetch fails but we have a token\n      // This allows the application to work even if profile endpoint is not available\n      if (response.status === 401 || response.status === 404) {\n        console.log('API: Creating fallback user object from token');\n        const email = sessionStorage.getItem('lastLoginEmail');\n        return {\n          id: 'authenticated-user',\n          email: email || 'user@example.com',\n          name: 'User',\n          authenticated: true\n        };\n      }\n      throw new Error(`Failed to fetch profile: ${response.statusText}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('API: Error fetching user profile:', error.message);\n\n    // Return a basic user object if we have a stored email\n    const email = sessionStorage.getItem('lastLoginEmail');\n    if (email) {\n      return {\n        id: 'authenticated-user',\n        email: email,\n        name: 'User',\n        authenticated: true\n      };\n    }\n    throw error;\n  }\n};\n\n// Directories\nexport const getDirectories = async () => {\n  try {\n    console.log('API: Fetching directories');\n\n    // Get token from localStorage\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Authentication required');\n    }\n    console.log('Using token for directories (first few chars):', token.substring(0, 10) + '...');\n\n    // Use Bearer format for JWT tokens\n    const headers = {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    };\n\n    // Try with and without trailing slash\n    let response;\n    try {\n      // First attempt with trailing slash\n      response = await fetch('http://localhost:8000/api/directories/', {\n        method: 'GET',\n        headers: headers\n      });\n\n      // If 404, try without trailing slash\n      if (response.status === 404) {\n        console.log('API: Trying directories endpoint without trailing slash');\n        response = await fetch('http://localhost:8000/api/directories', {\n          method: 'GET',\n          headers: headers\n        });\n      }\n    } catch (fetchError) {\n      console.error('API: Network error fetching directories:', fetchError);\n      throw fetchError;\n    }\n\n    // Log response status\n    console.log('API: Directories fetch response status:', response.status);\n    if (!response.ok) {\n      console.error('API: Directories fetch failed:', response.status, response.statusText);\n      throw new Error(`Failed to fetch directories: ${response.statusText}`);\n    }\n    const data = await response.json();\n    console.log('API: Directories fetch successful:', data);\n    return data;\n  } catch (error) {\n    console.error('API: Error fetching directories:', error.message);\n\n    // Return mock data if real data fetch fails\n    console.log('Returning mock directory data');\n    return [{\n      id: 1,\n      name: 'Documents',\n      path: '/documents',\n      color: '#4285F4'\n    }, {\n      id: 2,\n      name: 'Images',\n      path: '/images',\n      color: '#34A853'\n    }, {\n      id: 3,\n      name: 'Projects',\n      path: '/projects',\n      color: '#FBBC05'\n    }, {\n      id: 4,\n      name: 'Templates',\n      path: '/templates',\n      color: '#EA4335'\n    }];\n  }\n};\n\n// Chat API Functions\nexport const getChatHistory = async () => {\n  try {\n    console.log('API: Fetching chat history from RAG pipeline');\n\n    // Get token from localStorage\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Authentication required');\n    }\n    console.log('Using token for chat history (first few chars):', token.substring(0, 10) + '...');\n\n    // Use fetch API directly like other endpoints for consistency\n    const headers = {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    };\n\n    // Try possible endpoints - modify these to match your actual backend endpoints\n    const possibleEndpoints = ['http://localhost:8000/api/chat/history', 'http://localhost:8000/api/rag/chat/history', 'http://localhost:8000/api/rag/history', 'http://localhost:8000/api/rag/conversations'];\n    let response = null;\n    let endpoint = '';\n\n    // Try each endpoint until one works\n    for (const url of possibleEndpoints) {\n      try {\n        console.log(`API: Trying chat history endpoint: ${url}`);\n        const resp = await fetch(url, {\n          method: 'GET',\n          headers: headers\n        });\n        if (resp.ok) {\n          response = resp;\n          endpoint = url;\n          break;\n        }\n      } catch (e) {\n        console.log(`API: Endpoint ${url} failed:`, e.message);\n      }\n    }\n    if (response && response.ok) {\n      console.log(`API: Chat history fetch successful from ${endpoint}`);\n      const data = await response.json();\n      return data;\n    }\n\n    // If we reach here, none of the endpoints worked\n    console.error('API: All chat history endpoints failed');\n    throw new Error('No working chat history endpoint found');\n  } catch (error) {\n    console.error('API: Error fetching chat history:', error.message);\n\n    // Return mock data if real data fetch fails\n    console.log('Returning mock chat history data');\n    return [{\n      id: 1,\n      sender: 'System',\n      content: 'Hello! I\\'m the OatmealAI Assistant. How can I help you today?',\n      timestamp: new Date(Date.now() - 3600000).toISOString(),\n      isCurrentUser: false\n    }];\n  }\n};\nexport const sendChatMessage = async message => {\n  try {\n    console.log('API: Sending chat message to RAG pipeline');\n\n    // Get token from localStorage\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Authentication required');\n    }\n\n    // Use fetch API directly like other endpoints for consistency\n    const headers = {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    };\n\n    // First, add the user message to the UI immediately\n    const userMessage = {\n      id: Date.now(),\n      content: message,\n      sender: 'User',\n      timestamp: new Date().toISOString(),\n      isCurrentUser: true\n    };\n\n    // Try possible endpoints - modify these to match your actual backend endpoints\n    const possibleEndpoints = ['http://localhost:8000/api/chat/message', 'http://localhost:8000/api/rag/chat/query', 'http://localhost:8000/api/rag/query', 'http://localhost:8000/api/rag/answer'];\n\n    // Create various payload formats to try\n    const payloads = [{\n      message\n    }, {\n      query: message\n    }, {\n      question: message\n    }, {\n      content: message\n    }, {\n      message,\n      conversation_id: \"default-chat\"\n    }, {\n      query: message,\n      conversation_id: \"default-chat\"\n    }];\n    let response = null;\n    let endpoint = '';\n    let payload = {};\n\n    // Try each endpoint with each payload until one works\n    for (const url of possibleEndpoints) {\n      for (const data of payloads) {\n        try {\n          console.log(`API: Trying RAG endpoint: ${url} with payload:`, data);\n          const resp = await fetch(url, {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify(data)\n          });\n          if (resp.ok) {\n            response = resp;\n            endpoint = url;\n            payload = data;\n            break;\n          }\n        } catch (e) {\n          console.log(`API: Endpoint ${url} with payload ${JSON.stringify(data)} failed:`, e.message);\n        }\n      }\n      if (response) break;\n    }\n    if (response && response.ok) {\n      console.log(`API: Message sent successfully to ${endpoint} with payload:`, payload);\n      const data = await response.json();\n      console.log('API: RAG response received:', data);\n\n      // Handle different possible response formats\n      let responseContent = '';\n      let responseSources = [];\n      if (data.response) {\n        responseContent = data.response;\n        responseSources = data.sources || [];\n      } else if (data.answer) {\n        responseContent = data.answer;\n        responseSources = data.sources || [];\n      } else if (data.content) {\n        responseContent = data.content;\n        responseSources = data.sources || [];\n      } else if (data.message) {\n        responseContent = typeof data.message === 'object' ? data.message.content : data.message;\n        responseSources = data.sources || [];\n      } else if (typeof data === 'string') {\n        responseContent = data;\n      } else {\n        responseContent = \"I received your message but I'm not sure how to interpret the response.\";\n      }\n      return {\n        userMessage: userMessage,\n        aiResponse: {\n          id: Date.now() + 1,\n          content: responseContent,\n          sender: 'OatmealAI',\n          timestamp: new Date().toISOString(),\n          isCurrentUser: false,\n          sources: responseSources\n        }\n      };\n    }\n\n    // If we reach here, we couldn't connect to any endpoint\n    // Return a mock response that simulates AI behavior\n    console.log('API: All RAG endpoints failed. Using offline AI simulation.');\n\n    // Simulate a thinking delay\n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    // Generate a simple response based on the user's message\n    const responses = {\n      hello: \"Hello! How can I help you today?\",\n      hi: \"Hi there! What can I do for you?\",\n      help: \"I'm here to help! What would you like to know about OatmealAI?\",\n      default: `I understand you're asking about \"${message}\". While I'm currently operating in offline mode, I'd normally provide information about this topic from our knowledge base. Can I help with anything else?`\n    };\n    const lowerMessage = message.toLowerCase();\n    let mockResponse = '';\n    if (lowerMessage.includes('hello') || lowerMessage.includes('hi ')) {\n      mockResponse = responses.hello;\n    } else if (lowerMessage.includes('help')) {\n      mockResponse = responses.help;\n    } else {\n      mockResponse = responses.default;\n    }\n    return {\n      userMessage: userMessage,\n      aiResponse: {\n        id: Date.now() + 1,\n        content: mockResponse,\n        sender: 'OatmealAI',\n        timestamp: new Date().toISOString(),\n        isCurrentUser: false,\n        sources: []\n      }\n    };\n  } catch (error) {\n    console.error('API: Error sending message to RAG:', error.message);\n\n    // Return a mock success response if the real request fails\n    console.log('Returning mock RAG response');\n\n    // Simulate a thinking delay\n    await new Promise(resolve => setTimeout(resolve, 800));\n    return {\n      userMessage: {\n        id: Date.now(),\n        content: message,\n        sender: 'User',\n        timestamp: new Date().toISOString(),\n        isCurrentUser: true\n      },\n      aiResponse: {\n        id: Date.now() + 1,\n        content: `I understand you're asking about \"${message}\". I'm operating in offline mode at the moment, but I'd be happy to assist you when our systems are back online.`,\n        sender: 'OatmealAI',\n        timestamp: new Date().toISOString(),\n        isCurrentUser: false\n      }\n    };\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","headers","interceptors","request","use","config","token","localStorage","getItem","console","log","url","Authorization","substring","error","Promise","reject","response","status","method","loginUser","credentials","email","post","data","_error$response","_error$response$data","message","Error","signupUser","userData","_error$response2","_error$response2$data","getUserProfile","fetch","ok","statusText","sessionStorage","id","name","authenticated","json","getDirectories","fetchError","path","color","getChatHistory","possibleEndpoints","endpoint","resp","e","sender","content","timestamp","Date","now","toISOString","isCurrentUser","sendChatMessage","userMessage","payloads","query","question","conversation_id","payload","body","JSON","stringify","responseContent","responseSources","sources","answer","aiResponse","resolve","setTimeout","responses","hello","hi","help","default","lowerMessage","toLowerCase","mockResponse","includes"],"sources":["C:/Users/STSC/Downloads/Agent-Backend-main (3)/my-app/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// Create an axios instance with the base URL\r\nconst api = axios.create({\r\n  baseURL: 'http://localhost:8000', // Updated to correct backend URL\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  }\r\n});\r\n\r\n// Request interceptor - adds auth token if available\r\napi.interceptors.request.use(\r\n  (config) => {\r\n    // Get token from localStorage\r\n    const token = localStorage.getItem('token');\r\n    \r\n    // Check if token exists\r\n    if (token) {\r\n      console.log(`API Request: Using token for ${config.url}`);\r\n      \r\n      // JWT tokens should use Bearer prefix, not Token\r\n      config.headers.Authorization = `Bearer ${token}`;\r\n      \r\n      // Debugging log\r\n      console.log('Authorization header:', config.headers.Authorization.substring(0, 15) + '...');\r\n    } else {\r\n      console.log('API Request: No token found');\r\n    }\r\n    \r\n    return config;\r\n  },\r\n  (error) => {\r\n    console.error('Request interceptor error:', error);\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor - handles auth errors\r\napi.interceptors.response.use(\r\n  (response) => {\r\n    return response;\r\n  },\r\n  (error) => {\r\n    // Handle 401 Unauthorized errors\r\n    if (error.response && error.response.status === 401) {\r\n      console.error('401 Unauthorized error from API:', {\r\n        url: error.config.url,\r\n        method: error.config.method,\r\n        headers: error.config.headers.Authorization ? \r\n          error.config.headers.Authorization.substring(0, 15) + '...' : 'none'\r\n      });\r\n    }\r\n    \r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Auth functions\r\nexport const loginUser = async (credentials) => {\r\n  try {\r\n    console.log('API: Sending login request with:', credentials.email);\r\n    const response = await api.post('/api/auth/login/', credentials);\r\n    console.log('API: Login response status:', response.status);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('API: Login error:', error.message);\r\n    if (error.response) {\r\n      console.error('API: Server response:', error.response.data);\r\n    }\r\n    throw new Error(error.response?.data?.message || 'Login failed. Please try again.');\r\n  }\r\n};\r\n\r\nexport const signupUser = async (userData) => {\r\n  try {\r\n    const response = await api.post('/api/auth/signup/', userData);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('API: Signup error:', error.message);\r\n    throw new Error(error.response?.data?.message || 'Signup failed. Please try again.');\r\n  }\r\n};\r\n\r\n// User profile\r\nexport const getUserProfile = async () => {\r\n  // Use fetch API directly for better control\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    \r\n    if (!token) {\r\n      console.error('API: Cannot fetch profile - No token available');\r\n      throw new Error('Authentication required');\r\n    }\r\n    \r\n    console.log('API: Fetching user profile with token');\r\n    \r\n    // Use Bearer format for JWT tokens\r\n    const headers = {\r\n      'Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json'\r\n    };\r\n    \r\n    console.log('Profile request headers:', {\r\n      Authorization: headers.Authorization.substring(0, 15) + '...'\r\n    });\r\n    \r\n    // Updated URL to match the backend path\r\n    const response = await fetch('http://localhost:8000/api/auth/profile/', {\r\n      method: 'GET',\r\n      headers: headers\r\n    });\r\n    \r\n    // Log response status\r\n    console.log('API: Profile fetch response status:', response.status);\r\n    \r\n    if (!response.ok) {\r\n      console.error('API: Profile fetch failed:', response.status, response.statusText);\r\n      \r\n      // Return a basic user object if profile fetch fails but we have a token\r\n      // This allows the application to work even if profile endpoint is not available\r\n      if (response.status === 401 || response.status === 404) {\r\n        console.log('API: Creating fallback user object from token');\r\n        const email = sessionStorage.getItem('lastLoginEmail');\r\n        return {\r\n          id: 'authenticated-user',\r\n          email: email || 'user@example.com',\r\n          name: 'User',\r\n          authenticated: true\r\n        };\r\n      }\r\n      \r\n      throw new Error(`Failed to fetch profile: ${response.statusText}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    return data;\r\n  } catch (error) {\r\n    console.error('API: Error fetching user profile:', error.message);\r\n    \r\n    // Return a basic user object if we have a stored email\r\n    const email = sessionStorage.getItem('lastLoginEmail');\r\n    if (email) {\r\n      return {\r\n        id: 'authenticated-user',\r\n        email: email,\r\n        name: 'User',\r\n        authenticated: true\r\n      };\r\n    }\r\n    \r\n    throw error;\r\n  }\r\n};\r\n\r\n// Directories\r\nexport const getDirectories = async () => {\r\n  try {\r\n    console.log('API: Fetching directories');\r\n    \r\n    // Get token from localStorage\r\n    const token = localStorage.getItem('token');\r\n    if (!token) {\r\n      throw new Error('Authentication required');\r\n    }\r\n    \r\n    console.log('Using token for directories (first few chars):', token.substring(0, 10) + '...');\r\n    \r\n    // Use Bearer format for JWT tokens\r\n    const headers = {\r\n      'Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json'\r\n    };\r\n    \r\n    // Try with and without trailing slash\r\n    let response;\r\n    try {\r\n      // First attempt with trailing slash\r\n      response = await fetch('http://localhost:8000/api/directories/', {\r\n        method: 'GET',\r\n        headers: headers\r\n      });\r\n      \r\n      // If 404, try without trailing slash\r\n      if (response.status === 404) {\r\n        console.log('API: Trying directories endpoint without trailing slash');\r\n        response = await fetch('http://localhost:8000/api/directories', {\r\n          method: 'GET',\r\n          headers: headers\r\n        });\r\n      }\r\n    } catch (fetchError) {\r\n      console.error('API: Network error fetching directories:', fetchError);\r\n      throw fetchError;\r\n    }\r\n    \r\n    // Log response status\r\n    console.log('API: Directories fetch response status:', response.status);\r\n    \r\n    if (!response.ok) {\r\n      console.error('API: Directories fetch failed:', response.status, response.statusText);\r\n      throw new Error(`Failed to fetch directories: ${response.statusText}`);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    console.log('API: Directories fetch successful:', data);\r\n    return data;\r\n  } catch (error) {\r\n    console.error('API: Error fetching directories:', error.message);\r\n    \r\n    // Return mock data if real data fetch fails\r\n    console.log('Returning mock directory data');\r\n    return [\r\n      { id: 1, name: 'Documents', path: '/documents', color: '#4285F4' },\r\n      { id: 2, name: 'Images', path: '/images', color: '#34A853' },\r\n      { id: 3, name: 'Projects', path: '/projects', color: '#FBBC05' },\r\n      { id: 4, name: 'Templates', path: '/templates', color: '#EA4335' }\r\n    ];\r\n  }\r\n};\r\n\r\n// Chat API Functions\r\nexport const getChatHistory = async () => {\r\n  try {\r\n    console.log('API: Fetching chat history from RAG pipeline');\r\n    \r\n    // Get token from localStorage\r\n    const token = localStorage.getItem('token');\r\n    if (!token) {\r\n      throw new Error('Authentication required');\r\n    }\r\n    \r\n    console.log('Using token for chat history (first few chars):', token.substring(0, 10) + '...');\r\n    \r\n    // Use fetch API directly like other endpoints for consistency\r\n    const headers = {\r\n      'Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json'\r\n    };\r\n    \r\n    // Try possible endpoints - modify these to match your actual backend endpoints\r\n    const possibleEndpoints = [\r\n      'http://localhost:8000/api/chat/history',\r\n      'http://localhost:8000/api/rag/chat/history',\r\n      'http://localhost:8000/api/rag/history',\r\n      'http://localhost:8000/api/rag/conversations'\r\n    ];\r\n    \r\n    let response = null;\r\n    let endpoint = '';\r\n    \r\n    // Try each endpoint until one works\r\n    for (const url of possibleEndpoints) {\r\n      try {\r\n        console.log(`API: Trying chat history endpoint: ${url}`);\r\n        const resp = await fetch(url, {\r\n          method: 'GET',\r\n          headers: headers\r\n        });\r\n        \r\n        if (resp.ok) {\r\n          response = resp;\r\n          endpoint = url;\r\n          break;\r\n        }\r\n      } catch (e) {\r\n        console.log(`API: Endpoint ${url} failed:`, e.message);\r\n      }\r\n    }\r\n    \r\n    if (response && response.ok) {\r\n      console.log(`API: Chat history fetch successful from ${endpoint}`);\r\n      const data = await response.json();\r\n      return data;\r\n    }\r\n    \r\n    // If we reach here, none of the endpoints worked\r\n    console.error('API: All chat history endpoints failed');\r\n    throw new Error('No working chat history endpoint found');\r\n  } catch (error) {\r\n    console.error('API: Error fetching chat history:', error.message);\r\n    \r\n    // Return mock data if real data fetch fails\r\n    console.log('Returning mock chat history data');\r\n    return [\r\n      { \r\n        id: 1, \r\n        sender: 'System', \r\n        content: 'Hello! I\\'m the OatmealAI Assistant. How can I help you today?', \r\n        timestamp: new Date(Date.now() - 3600000).toISOString(),\r\n        isCurrentUser: false\r\n      }\r\n    ];\r\n  }\r\n};\r\n\r\nexport const sendChatMessage = async (message) => {\r\n  try {\r\n    console.log('API: Sending chat message to RAG pipeline');\r\n    \r\n    // Get token from localStorage\r\n    const token = localStorage.getItem('token');\r\n    if (!token) {\r\n      throw new Error('Authentication required');\r\n    }\r\n    \r\n    // Use fetch API directly like other endpoints for consistency\r\n    const headers = {\r\n      'Authorization': `Bearer ${token}`,\r\n      'Content-Type': 'application/json'\r\n    };\r\n    \r\n    // First, add the user message to the UI immediately\r\n    const userMessage = { \r\n      id: Date.now(),\r\n      content: message,\r\n      sender: 'User',\r\n      timestamp: new Date().toISOString(),\r\n      isCurrentUser: true\r\n    };\r\n    \r\n    // Try possible endpoints - modify these to match your actual backend endpoints\r\n    const possibleEndpoints = [\r\n      'http://localhost:8000/api/chat/message',\r\n      'http://localhost:8000/api/rag/chat/query',\r\n      'http://localhost:8000/api/rag/query',\r\n      'http://localhost:8000/api/rag/answer'\r\n    ];\r\n    \r\n    // Create various payload formats to try\r\n    const payloads = [\r\n      { message },\r\n      { query: message },\r\n      { question: message },\r\n      { content: message },\r\n      { message, conversation_id: \"default-chat\" },\r\n      { query: message, conversation_id: \"default-chat\" }\r\n    ];\r\n    \r\n    let response = null;\r\n    let endpoint = '';\r\n    let payload = {};\r\n    \r\n    // Try each endpoint with each payload until one works\r\n    for (const url of possibleEndpoints) {\r\n      for (const data of payloads) {\r\n        try {\r\n          console.log(`API: Trying RAG endpoint: ${url} with payload:`, data);\r\n          const resp = await fetch(url, {\r\n            method: 'POST',\r\n            headers: headers,\r\n            body: JSON.stringify(data)\r\n          });\r\n          \r\n          if (resp.ok) {\r\n            response = resp;\r\n            endpoint = url;\r\n            payload = data;\r\n            break;\r\n          }\r\n        } catch (e) {\r\n          console.log(`API: Endpoint ${url} with payload ${JSON.stringify(data)} failed:`, e.message);\r\n        }\r\n      }\r\n      \r\n      if (response) break;\r\n    }\r\n    \r\n    if (response && response.ok) {\r\n      console.log(`API: Message sent successfully to ${endpoint} with payload:`, payload);\r\n      const data = await response.json();\r\n      console.log('API: RAG response received:', data);\r\n      \r\n      // Handle different possible response formats\r\n      let responseContent = '';\r\n      let responseSources = [];\r\n      \r\n      if (data.response) {\r\n        responseContent = data.response;\r\n        responseSources = data.sources || [];\r\n      } else if (data.answer) {\r\n        responseContent = data.answer;\r\n        responseSources = data.sources || [];\r\n      } else if (data.content) {\r\n        responseContent = data.content;\r\n        responseSources = data.sources || [];\r\n      } else if (data.message) {\r\n        responseContent = typeof data.message === 'object' ? data.message.content : data.message;\r\n        responseSources = data.sources || [];\r\n      } else if (typeof data === 'string') {\r\n        responseContent = data;\r\n      } else {\r\n        responseContent = \"I received your message but I'm not sure how to interpret the response.\";\r\n      }\r\n      \r\n      return {\r\n        userMessage: userMessage,\r\n        aiResponse: {\r\n          id: Date.now() + 1,\r\n          content: responseContent,\r\n          sender: 'OatmealAI',\r\n          timestamp: new Date().toISOString(),\r\n          isCurrentUser: false,\r\n          sources: responseSources\r\n        }\r\n      };\r\n    }\r\n    \r\n    // If we reach here, we couldn't connect to any endpoint\r\n    // Return a mock response that simulates AI behavior\r\n    console.log('API: All RAG endpoints failed. Using offline AI simulation.');\r\n    \r\n    // Simulate a thinking delay\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n    \r\n    // Generate a simple response based on the user's message\r\n    const responses = {\r\n      hello: \"Hello! How can I help you today?\",\r\n      hi: \"Hi there! What can I do for you?\",\r\n      help: \"I'm here to help! What would you like to know about OatmealAI?\",\r\n      default: `I understand you're asking about \"${message}\". While I'm currently operating in offline mode, I'd normally provide information about this topic from our knowledge base. Can I help with anything else?`\r\n    };\r\n    \r\n    const lowerMessage = message.toLowerCase();\r\n    let mockResponse = '';\r\n    \r\n    if (lowerMessage.includes('hello') || lowerMessage.includes('hi ')) {\r\n      mockResponse = responses.hello;\r\n    } else if (lowerMessage.includes('help')) {\r\n      mockResponse = responses.help;\r\n    } else {\r\n      mockResponse = responses.default;\r\n    }\r\n    \r\n    return {\r\n      userMessage: userMessage,\r\n      aiResponse: {\r\n        id: Date.now() + 1,\r\n        content: mockResponse,\r\n        sender: 'OatmealAI',\r\n        timestamp: new Date().toISOString(),\r\n        isCurrentUser: false,\r\n        sources: []\r\n      }\r\n    };\r\n  } catch (error) {\r\n    console.error('API: Error sending message to RAG:', error.message);\r\n    \r\n    // Return a mock success response if the real request fails\r\n    console.log('Returning mock RAG response');\r\n    \r\n    // Simulate a thinking delay\r\n    await new Promise(resolve => setTimeout(resolve, 800));\r\n    \r\n    return { \r\n      userMessage: {\r\n        id: Date.now(),\r\n        content: message,\r\n        sender: 'User',\r\n        timestamp: new Date().toISOString(),\r\n        isCurrentUser: true\r\n      },\r\n      aiResponse: {\r\n        id: Date.now() + 1,\r\n        content: `I understand you're asking about \"${message}\". I'm operating in offline mode at the moment, but I'd be happy to assist you when our systems are back online.`,\r\n        sender: 'OatmealAI',\r\n        timestamp: new Date().toISOString(),\r\n        isCurrentUser: false\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
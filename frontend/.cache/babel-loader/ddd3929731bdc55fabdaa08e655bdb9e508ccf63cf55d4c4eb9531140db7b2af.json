{"ast":null,"code":"import axios from 'axios';\n\n// Create an axios instance with the base URL\nconst api = axios.create({\n  baseURL: 'http://127.0.0.1:8000',\n  // Updated to match the exact running server address\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Request interceptor - adds auth token if available\napi.interceptors.request.use(config => {\n  // Get token from localStorage\n  const token = localStorage.getItem('token');\n\n  // Check if token exists\n  if (token) {\n    var _config$headers$Autho;\n    console.log(`API Request: Using token for ${config.url}`);\n\n    // Check token format - use Bearer for JWT tokens, Token for Django tokens\n    if (token.startsWith('eyJ')) {\n      // JWT format tokens should use Bearer\n      config.headers.Authorization = `Bearer ${token}`;\n      console.log('Using Bearer format for JWT token');\n    } else {\n      // Other token formats use the Django REST Framework Token format\n      config.headers.Authorization = `Token ${token}`;\n      console.log('Using Django REST Framework Token format');\n    }\n\n    // Add detailed debug info for troubleshooting\n    console.log('Authorization header:', `${config.headers.Authorization.split(' ')[0]} ${(_config$headers$Autho = config.headers.Authorization.split(' ')[1]) === null || _config$headers$Autho === void 0 ? void 0 : _config$headers$Autho.substring(0, 10)}...`);\n    console.log('Token length:', token.length);\n  } else {\n    console.log('API Request: No token found');\n  }\n  return config;\n}, error => {\n  console.error('Request interceptor error:', error);\n  return Promise.reject(error);\n});\n\n// Response interceptor - handles auth errors\napi.interceptors.response.use(response => {\n  return response;\n}, error => {\n  // Handle 401 Unauthorized errors\n  if (error.response && error.response.status === 401) {\n    console.error('401 Unauthorized error from API:', {\n      url: error.config.url,\n      method: error.config.method,\n      headers: error.config.headers.Authorization ? error.config.headers.Authorization.substring(0, 20) + '...' : 'none',\n      data: error.response.data\n    });\n\n    // Check if token was invalid\n    if (error.response.data && (error.response.data.detail === 'Invalid token' || error.response.data.message === 'Invalid token')) {\n      console.error('Token was rejected by server - may need to log in again');\n\n      // Keep the token for now, but log the issue\n      // Don't automatically clear it to prevent logout loops\n    }\n  }\n  return Promise.reject(error);\n});\n\n// Auth functions\nexport const loginUser = async credentials => {\n  try {\n    console.log('API: Sending login request');\n\n    // Handle both object credentials and direct email/password parameters\n    let email, password;\n    if (typeof credentials === 'object' && credentials !== null) {\n      // Handle credentials as an object\n      email = credentials.email;\n      password = credentials.password;\n    } else {\n      // This should never happen, but we'll handle it for robustness\n      console.error('Invalid credentials format:', credentials);\n      throw new Error('Invalid login request format');\n    }\n\n    // Log the email we're using (but never log passwords)\n    console.log('API: Login attempt for:', email);\n\n    // Define different payload formats to try\n    const payloadFormats = [{\n      endpoint: '/api/auth/login/',\n      payload: {\n        email,\n        password\n      }\n    }, {\n      endpoint: '/api/auth/login/',\n      payload: {\n        username: email,\n        password\n      }\n    }, {\n      endpoint: '/api/login/',\n      payload: {\n        email,\n        password\n      }\n    }, {\n      endpoint: '/api/token/',\n      payload: {\n        username: email,\n        password\n      }\n    }, {\n      endpoint: '/api/token/',\n      payload: {\n        email,\n        password\n      }\n    }];\n\n    // Try each payload format\n    let lastError = null;\n    let response = null;\n    for (const attempt of payloadFormats) {\n      try {\n        console.log(`Trying login with endpoint: ${attempt.endpoint}`);\n        console.log('Using payload keys:', Object.keys(attempt.payload).join(', '));\n        response = await api.post(attempt.endpoint, attempt.payload);\n        console.log(`Successful login with ${attempt.endpoint}`);\n        break; // Break the loop if successful\n      } catch (error) {\n        lastError = error;\n        console.log(`Login attempt failed with ${attempt.endpoint}:`, error.response ? error.response.status : error.message);\n\n        // Don't retry if we got a 401 (invalid credentials)\n        if (error.response && error.response.status === 401) {\n          throw error; // Re-throw to handle invalid credentials properly\n        }\n\n        // Continue to next attempt for other errors\n      }\n    }\n\n    // If all attempts failed, throw the last error\n    if (!response) {\n      console.error('All login attempts failed');\n      throw lastError || new Error('Failed to connect to backend');\n    }\n    console.log('Login response structure:', Object.keys(response.data).join(', '));\n\n    // Extract token from various possible formats\n    let token = null;\n    if (response.data.token) {\n      token = response.data.token;\n      console.log('Found token in response.data.token');\n    } else if (response.data.access) {\n      token = response.data.access;\n      console.log('Found token in response.data.access');\n    } else if (response.data.key) {\n      token = response.data.key;\n      console.log('Found token in response.data.key');\n    } else if (typeof response.data === 'string') {\n      // Sometimes the API returns the token directly as a string\n      token = response.data;\n      console.log('Response data is a string, using as token');\n    } else {\n      // Loop through all properties to find one that might be a token\n      for (const key in response.data) {\n        if (typeof response.data[key] === 'string' && (response.data[key].length > 20 || key.toLowerCase().includes('token'))) {\n          token = response.data[key];\n          console.log(`Found possible token in response.data.${key}`);\n          break;\n        }\n      }\n    }\n    if (!token) {\n      console.error('No token found in login response:', response.data);\n      throw new Error('Authentication failed: No token in response');\n    }\n\n    // Log details about the token to help with debugging\n    console.log('Token length:', token.length);\n    console.log('Token starts with:', token.substring(0, 10) + '...');\n    console.log('Appears to be JWT:', token.startsWith('eyJ'));\n\n    // Store the token\n    localStorage.setItem('token', token);\n\n    // Store user info if available in the response\n    if (response.data.user) {\n      console.log('User data found in response:', Object.keys(response.data.user).join(', '));\n      const userData = response.data.user;\n      if (userData.email) {\n        sessionStorage.setItem('lastLoginEmail', userData.email);\n      } else if (typeof email === 'string') {\n        sessionStorage.setItem('lastLoginEmail', email);\n      }\n      if (userData.name) {\n        sessionStorage.setItem('userName', userData.name);\n      } else if (userData.username) {\n        sessionStorage.setItem('userName', userData.username);\n      } else if (userData.first_name) {\n        const fullName = userData.last_name ? `${userData.first_name} ${userData.last_name}` : userData.first_name;\n        sessionStorage.setItem('userName', fullName);\n      } else if (userData.id) {\n        // If we only have user ID, store that\n        sessionStorage.setItem('userId', userData.id.toString());\n      }\n    } else {\n      // If we don't have user info, store the email we logged in with\n      if (typeof email === 'string') {\n        sessionStorage.setItem('lastLoginEmail', email);\n\n        // Extract username from email for a fallback user name\n        const username = email.split('@')[0];\n        if (username) {\n          // Capitalize first letter of username for better display\n          const displayName = username.charAt(0).toUpperCase() + username.slice(1);\n          sessionStorage.setItem('userName', displayName);\n        }\n      }\n    }\n    return {\n      ...response.data,\n      token: token,\n      // Ensure token is in the returned data\n      success: true\n    };\n  } catch (error) {\n    console.error('Login error:', error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\n    throw error;\n  }\n};\nexport const signupUser = async userData => {\n  try {\n    const response = await api.post('/api/auth/signup/', userData);\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    console.error('API: Signup error:', error.message);\n    throw new Error(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Signup failed. Please try again.');\n  }\n};\n\n// User profile\nexport const getUserProfile = async () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Authentication required');\n    }\n\n    // Determine the correct authentication header based on token format\n    let headers = {};\n    if (token.startsWith('eyJ')) {\n      // Looks like a JWT token\n      headers.Authorization = `Bearer ${token}`;\n      console.log('getUserProfile: Using Bearer format for JWT token');\n    } else {\n      // Use Token format for other types\n      headers.Authorization = `Token ${token}`;\n      console.log('getUserProfile: Using Django REST Framework Token format');\n    }\n\n    // Try multiple profile endpoints that might exist\n    const possibleEndpoints = ['/apiV1/profile/', '/apiV1/user/profile/', '/apiV1/user/', '/api/auth/profile/', '/api/auth/user/', '/api/user/profile/', '/api/user/', '/api/profile/', '/api/me/', '/admin/' // Try admin endpoint as a test for authentication\n    ];\n    let lastError = null;\n    let userData = null;\n\n    // Try each endpoint until one works\n    for (const endpoint of possibleEndpoints) {\n      try {\n        console.log(`Trying to fetch profile from ${endpoint}`);\n        const response = await api.get(endpoint, {\n          headers\n        });\n        if (response.status === 200 && response.data) {\n          console.log(`Profile found at ${endpoint}:`, response.status);\n          userData = response.data;\n          break;\n        }\n      } catch (endpointError) {\n        console.log(`Profile not found at ${endpoint}:`, endpointError.response ? endpointError.response.status : 'network error');\n        lastError = endpointError;\n        // Continue to the next endpoint\n      }\n    }\n\n    // If we found user data from any endpoint\n    if (userData) {\n      console.log('Profile data found:', Object.keys(userData).join(', '));\n\n      // Store key user info in session storage for fallback\n      if (userData.email) {\n        sessionStorage.setItem('lastLoginEmail', userData.email);\n      }\n      if (userData.name) {\n        sessionStorage.setItem('userName', userData.name);\n      } else if (userData.username) {\n        sessionStorage.setItem('userName', userData.username);\n      } else if (userData.first_name) {\n        const fullName = userData.last_name ? `${userData.first_name} ${userData.last_name}` : userData.first_name;\n        sessionStorage.setItem('userName', fullName);\n      }\n      return userData;\n    }\n\n    // If we get here, no endpoints worked but we have a token\n    // Create a fallback profile based on stored session data\n    console.log('No profile endpoints successful, using fallback data');\n    const email = sessionStorage.getItem('lastLoginEmail');\n    const name = sessionStorage.getItem('userName');\n    if (email) {\n      return {\n        email: email,\n        name: name || 'User',\n        profile_picture: null\n      };\n    }\n\n    // If we have no email, re-throw the last error\n    throw lastError || new Error('Failed to fetch profile from all endpoints');\n  } catch (error) {\n    console.error('Error fetching user profile:', error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\n\n    // Create a fallback user object if profile fetch fails\n    const email = sessionStorage.getItem('lastLoginEmail');\n    if (email) {\n      return {\n        email: email,\n        name: sessionStorage.getItem('userName') || 'User',\n        profile_picture: null\n      };\n    }\n    throw error;\n  }\n};\n\n// Directories\nexport const getDirectories = async () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Authentication required');\n    }\n\n    // Try with trailing slash first (Django often requires this)\n    const response = await api.get('/apiV1/directories/', {\n      headers: {\n        Authorization: `Token ${token}` // Using Token format for Django REST Framework\n      }\n    });\n    console.log('Directories response:', response.status, response.data);\n    return response.data;\n  } catch (error) {\n    // If we get a 404 with trailing slash, try without\n    if (error.response && error.response.status === 404) {\n      try {\n        const response = await api.get('/apiV1/directories', {\n          headers: {\n            Authorization: `Token ${token}`\n          }\n        });\n        console.log('Directories response (without trailing slash):', response.status, response.data);\n        return response.data;\n      } catch (retryError) {\n        console.error('Error fetching directories (retry):', retryError.response ? retryError.response.status : retryError.message);\n        throw retryError;\n      }\n    }\n    console.error('Error fetching directories:', error.response ? error.response.status : error.message);\n\n    // Return some mock directory data if the API fails\n    return [{\n      id: 1,\n      name: 'Documents',\n      path: '/documents',\n      color: '#4285F4'\n    }, {\n      id: 2,\n      name: 'Images',\n      path: '/images',\n      color: '#34A853'\n    }, {\n      id: 3,\n      name: 'Projects',\n      path: '/projects',\n      color: '#FBBC05'\n    }, {\n      id: 4,\n      name: 'Reports',\n      path: '/reports',\n      color: '#EA4335'\n    }];\n  }\n};\n\n// Chat API Functions\nexport const getChatHistory = async () => {\n  try {\n    // Since there's no specific chat history endpoint, we'll return an empty array\n    // The Chat component will handle creating the initial welcome message\n    return [];\n  } catch (error) {\n    console.error('Error fetching chat history:', error);\n    return [];\n  }\n};\nexport const sendChatMessage = async message => {\n  try {\n    // Handle test connection request\n    if (message === '__test_connection__') {\n      console.log('Testing connection to RAG pipeline...');\n      try {\n        const token = localStorage.getItem('token');\n        if (!token) {\n          return {\n            success: false,\n            error: 'No authentication token'\n          };\n        }\n\n        // Always use Django REST Framework Token format\n        const headers = {\n          'Content-Type': 'application/json',\n          'Authorization': `Token ${token}`\n        };\n        console.log('Test connection: Using Django REST Framework Token format');\n\n        // Try multiple endpoints to see if any respond\n        const testEndpoints = ['/apiV1/chat/', '/api/chat/', '/apiV1/ping/', '/api/health/', '/'];\n        for (const endpoint of testEndpoints) {\n          try {\n            // For the chat endpoints, use GET for connection test\n            console.log(`Testing connection to endpoint: ${endpoint}`);\n            const response = await api.get(endpoint, {\n              headers\n            });\n            console.log(`Successfully connected to ${endpoint} (${response.status})`);\n            return {\n              success: true,\n              endpoint: endpoint,\n              message: `Connected to RAG pipeline at ${endpoint}`\n            };\n          } catch (endpointError) {\n            // If we get a 404, the server is up at ${endpoint} but returned 404\n            if (endpointError.response && endpointError.response.status === 404) {\n              console.log(`Server is up at ${endpoint} but returned 404`);\n              // Instead of treating 404 as success, track that the backend is available\n              // but the endpoint is missing\n              return {\n                success: false,\n                serverRunning: true,\n                endpoint: endpoint,\n                message: 'Backend server is running but API endpoint not found',\n                status: 404,\n                error: 'API endpoint not available'\n              };\n            }\n\n            // If we get a 401/403, the authentication is wrong, report it specially\n            if (endpointError.response && (endpointError.response.status === 401 || endpointError.response.status === 403)) {\n              var _endpointError$respon;\n              console.error(`Authentication error at ${endpoint}: ${endpointError.response.status}`);\n              return {\n                success: false,\n                error: 'Authentication error',\n                authError: true,\n                status: endpointError.response.status,\n                message: ((_endpointError$respon = endpointError.response.data) === null || _endpointError$respon === void 0 ? void 0 : _endpointError$respon.detail) || 'Invalid authentication credentials'\n              };\n            }\n\n            // Otherwise continue trying other endpoints\n            console.log(`Failed to connect to ${endpoint}: ${endpointError.message}`);\n          }\n        }\n\n        // If all endpoints failed, return an error\n        return {\n          success: false,\n          error: 'Could not connect to any backend endpoints',\n          offline: true\n        };\n      } catch (error) {\n        console.error('Connection test failed:', error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\n        return {\n          success: false,\n          error: error.response ? `Server error (${error.response.status})` : 'Network error',\n          offline: true\n        };\n      }\n    }\n\n    // Regular message sending\n    const token = localStorage.getItem('token');\n    if (!token) {\n      throw new Error('Authentication required');\n    }\n\n    // Always use Django REST Framework Token format\n    const headers = {\n      'Content-Type': 'application/json',\n      'Authorization': `Token ${token}`\n    };\n    console.log('Using Django REST Framework Token format for message');\n    console.log('Sending message to RAG pipeline...');\n    try {\n      // Try the main chat endpoint first\n      const response = await api.post('/apiV1/chat/', {\n        message\n      }, {\n        headers\n      });\n      console.log('Chat response received:', response.status);\n      return {\n        success: true,\n        ai_response: response.data.response || response.data.message || response.data.reply || response.data,\n        sources: response.data.sources || []\n      };\n    } catch (error) {\n      // If the main endpoint fails with 404, try the alternative without trailing slash\n      if (error.response && error.response.status === 404) {\n        try {\n          console.log('Trying alternative chat endpoint without trailing slash...');\n          const response = await api.post('/apiV1/chat', {\n            message\n          }, {\n            headers\n          });\n          console.log('Chat response received from alternative endpoint:', response.status);\n          return {\n            success: true,\n            ai_response: response.data.response || response.data.message || response.data.reply || response.data,\n            sources: response.data.sources || []\n          };\n        } catch (retryError) {\n          throw retryError; // Let the outer catch handle this\n        }\n      }\n      throw error; // Re-throw if not a 404\n    }\n  } catch (error) {\n    console.error('Chat error:', error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\n\n    // Check specifically for authorization errors\n    if (error.response && (error.response.status === 401 || error.response.status === 403)) {\n      var _error$response$data2;\n      return {\n        success: false,\n        error: 'Authentication error',\n        authError: true,\n        status: error.response.status,\n        message: ((_error$response$data2 = error.response.data) === null || _error$response$data2 === void 0 ? void 0 : _error$response$data2.detail) || 'Invalid authentication credentials'\n      };\n    }\n    return {\n      success: false,\n      error: error.response ? `Server error (${error.response.status})` : 'Network error',\n      offline: true\n    };\n  }\n};\n\n// Function to diagnose API endpoints\nexport const checkApiEndpoints = async () => {\n  const token = localStorage.getItem('token');\n  if (!token) {\n    console.error('No authentication token available');\n    return {\n      authenticated: false,\n      endpoints: []\n    };\n  }\n\n  // Prepare headers\n  const headers = {\n    Authorization: `Token ${token}`\n  };\n\n  // List of endpoints to test\n  const endpoints = [\n  // Common API endpoints\n  {\n    method: 'GET',\n    url: '/api/auth/profile/'\n  }, {\n    method: 'GET',\n    url: '/api/directories/'\n  }, {\n    method: 'GET',\n    url: '/api/chat/'\n  }, {\n    method: 'POST',\n    url: '/api/chat/',\n    data: {\n      message: 'test'\n    }\n  },\n  // V1 API endpoints \n  {\n    method: 'GET',\n    url: '/apiV1/profile/'\n  }, {\n    method: 'GET',\n    url: '/apiV1/directories/'\n  }, {\n    method: 'GET',\n    url: '/apiV1/ping/'\n  }, {\n    method: 'POST',\n    url: '/apiV1/chat/',\n    data: {\n      message: 'test'\n    }\n  },\n  // Azure-specific endpoints (if any)\n  {\n    method: 'GET',\n    url: '/apiV1/azure/status/'\n  }];\n  const results = [];\n\n  // Test each endpoint\n  for (const endpoint of endpoints) {\n    try {\n      console.log(`Testing ${endpoint.method} ${endpoint.url}...`);\n      const config = {\n        method: endpoint.method,\n        url: endpoint.url,\n        headers: headers,\n        data: endpoint.data || null\n      };\n      const response = await axios(config);\n      results.push({\n        endpoint: endpoint.url,\n        method: endpoint.method,\n        status: response.status,\n        available: true,\n        data: typeof response.data === 'object' ? 'Object received' : 'Data received'\n      });\n      console.log(`✅ ${endpoint.method} ${endpoint.url} - Status: ${response.status}`);\n    } catch (error) {\n      var _error$response2, _error$response3, _error$response4;\n      results.push({\n        endpoint: endpoint.url,\n        method: endpoint.method,\n        status: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) || 'Network Error',\n        available: false,\n        error: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data) || error.message\n      });\n      console.log(`❌ ${endpoint.method} ${endpoint.url} - Error: ${((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) || error.message}`);\n    }\n  }\n\n  // Log the summary\n  const availableEndpoints = results.filter(e => e.available);\n  console.log(`API Endpoint Check Summary: ${availableEndpoints.length}/${endpoints.length} endpoints available`);\n  console.table(results);\n  return {\n    authenticated: true,\n    endpoints: results,\n    availableCount: availableEndpoints.length,\n    totalCount: endpoints.length\n  };\n};\n\n/**\r\n * Tests a specific endpoint and returns detailed status information\r\n * @param {string} endpoint - The endpoint path to test (e.g., '/api/chat/')\r\n * @returns {Object} - Object containing status information\r\n */\nexport const testEndpoint = async endpoint => {\n  const baseUrl = 'http://127.0.0.1:8000'; // Django backend URL\n  const url = `${baseUrl}${endpoint}`;\n  try {\n    // Get token if available and use Django REST Framework Token format\n    const token = localStorage.getItem('token');\n    const headers = token ? {\n      'Authorization': `Token ${token}`\n    } : {};\n    console.log(`Testing endpoint: ${url}`);\n    console.log('Authorization header:', token ? 'Token xxxx...' : 'None');\n\n    // For GET endpoints\n    const response = await axios.get(url, {\n      headers,\n      // Don't throw error on non-2xx responses - we want to handle them ourselves\n      validateStatus: () => true\n    });\n    console.log(`Endpoint ${url} response:`, response.status, response.statusText);\n\n    // A 404 means the server is running but endpoint doesn't exist\n    if (response.status === 404) {\n      return {\n        url,\n        status: 404,\n        available: false,\n        serverRunning: true,\n        message: \"Endpoint not found, but server is running\",\n        data: response.data\n      };\n    }\n\n    // Auth errors\n    if (response.status === 401 || response.status === 403) {\n      return {\n        url,\n        status: response.status,\n        available: false,\n        authError: true,\n        message: response.status === 401 ? \"Unauthorized - Invalid or missing token\" : \"Forbidden\",\n        data: response.data\n      };\n    }\n\n    // Success (2xx) responses\n    if (response.status >= 200 && response.status < 300) {\n      return {\n        url,\n        status: response.status,\n        available: true,\n        message: \"Endpoint available\",\n        data: response.data\n      };\n    }\n\n    // Other responses\n    return {\n      url,\n      status: response.status,\n      available: false,\n      message: `Endpoint responded with: ${response.status} ${response.statusText}`,\n      data: response.data\n    };\n  } catch (error) {\n    var _error$response5;\n    console.error(`Error testing endpoint ${url}:`, error);\n\n    // Network errors (server not running)\n    if (error.code === 'ERR_NETWORK') {\n      return {\n        url,\n        status: 'Network Error',\n        available: false,\n        serverRunning: false,\n        message: \"Server not running or network error\",\n        error: error.message\n      };\n    }\n    return {\n      url,\n      status: ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) || 'Error',\n      available: false,\n      message: `Error: ${error.message}`,\n      error: error.message\n    };\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","headers","interceptors","request","use","config","token","localStorage","getItem","_config$headers$Autho","console","log","url","startsWith","Authorization","split","substring","length","error","Promise","reject","response","status","method","data","detail","message","loginUser","credentials","email","password","Error","payloadFormats","endpoint","payload","username","lastError","attempt","Object","keys","join","post","access","key","toLowerCase","includes","setItem","user","userData","sessionStorage","name","first_name","fullName","last_name","id","toString","displayName","charAt","toUpperCase","slice","success","JSON","stringify","signupUser","_error$response","_error$response$data","getUserProfile","possibleEndpoints","get","endpointError","profile_picture","getDirectories","retryError","path","color","getChatHistory","sendChatMessage","testEndpoints","serverRunning","_endpointError$respon","authError","offline","ai_response","reply","sources","_error$response$data2","checkApiEndpoints","authenticated","endpoints","results","push","available","_error$response2","_error$response3","_error$response4","availableEndpoints","filter","e","table","availableCount","totalCount","testEndpoint","baseUrl","validateStatus","statusText","_error$response5","code"],"sources":["C:/Users/STSC/Downloads/Agent-Backend-main (3)/my-app/src/services/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// Create an axios instance with the base URL\r\nconst api = axios.create({\r\n  baseURL: 'http://127.0.0.1:8000', // Updated to match the exact running server address\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n  }\r\n});\r\n\r\n// Request interceptor - adds auth token if available\r\napi.interceptors.request.use(\r\n  (config) => {\r\n    // Get token from localStorage\r\n    const token = localStorage.getItem('token');\r\n    \r\n    // Check if token exists\r\n    if (token) {\r\n      console.log(`API Request: Using token for ${config.url}`);\r\n      \r\n      // Check token format - use Bearer for JWT tokens, Token for Django tokens\r\n      if (token.startsWith('eyJ')) {\r\n        // JWT format tokens should use Bearer\r\n        config.headers.Authorization = `Bearer ${token}`;\r\n        console.log('Using Bearer format for JWT token');\r\n      } else {\r\n        // Other token formats use the Django REST Framework Token format\r\n        config.headers.Authorization = `Token ${token}`;\r\n        console.log('Using Django REST Framework Token format');\r\n      }\r\n      \r\n      // Add detailed debug info for troubleshooting\r\n      console.log('Authorization header:', \r\n        `${config.headers.Authorization.split(' ')[0]} ${config.headers.Authorization.split(' ')[1]?.substring(0, 10)}...`);\r\n      console.log('Token length:', token.length);\r\n    } else {\r\n      console.log('API Request: No token found');\r\n    }\r\n    \r\n    return config;\r\n  },\r\n  (error) => {\r\n    console.error('Request interceptor error:', error);\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor - handles auth errors\r\napi.interceptors.response.use(\r\n  (response) => {\r\n    return response;\r\n  },\r\n  (error) => {\r\n    // Handle 401 Unauthorized errors\r\n    if (error.response && error.response.status === 401) {\r\n      console.error('401 Unauthorized error from API:', {\r\n        url: error.config.url,\r\n        method: error.config.method,\r\n        headers: error.config.headers.Authorization ? \r\n          error.config.headers.Authorization.substring(0, 20) + '...' : 'none',\r\n        data: error.response.data\r\n      });\r\n      \r\n      // Check if token was invalid\r\n      if (error.response.data && \r\n          (error.response.data.detail === 'Invalid token' || \r\n           error.response.data.message === 'Invalid token')) {\r\n        console.error('Token was rejected by server - may need to log in again');\r\n        \r\n        // Keep the token for now, but log the issue\r\n        // Don't automatically clear it to prevent logout loops\r\n      }\r\n    }\r\n    \r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Auth functions\r\nexport const loginUser = async (credentials) => {\r\n  try {\r\n    console.log('API: Sending login request');\r\n    \r\n    // Handle both object credentials and direct email/password parameters\r\n    let email, password;\r\n    \r\n    if (typeof credentials === 'object' && credentials !== null) {\r\n      // Handle credentials as an object\r\n      email = credentials.email;\r\n      password = credentials.password;\r\n    } else {\r\n      // This should never happen, but we'll handle it for robustness\r\n      console.error('Invalid credentials format:', credentials);\r\n      throw new Error('Invalid login request format');\r\n    }\r\n    \r\n    // Log the email we're using (but never log passwords)\r\n    console.log('API: Login attempt for:', email);\r\n    \r\n    // Define different payload formats to try\r\n    const payloadFormats = [\r\n      { endpoint: '/api/auth/login/', payload: { email, password } },\r\n      { endpoint: '/api/auth/login/', payload: { username: email, password } },\r\n      { endpoint: '/api/login/', payload: { email, password } },\r\n      { endpoint: '/api/token/', payload: { username: email, password } },\r\n      { endpoint: '/api/token/', payload: { email, password } }\r\n    ];\r\n    \r\n    // Try each payload format\r\n    let lastError = null;\r\n    let response = null;\r\n    \r\n    for (const attempt of payloadFormats) {\r\n      try {\r\n        console.log(`Trying login with endpoint: ${attempt.endpoint}`);\r\n        console.log('Using payload keys:', Object.keys(attempt.payload).join(', '));\r\n        \r\n        response = await api.post(attempt.endpoint, attempt.payload);\r\n        console.log(`Successful login with ${attempt.endpoint}`);\r\n        break; // Break the loop if successful\r\n      } catch (error) {\r\n        lastError = error;\r\n        console.log(`Login attempt failed with ${attempt.endpoint}:`, \r\n          error.response ? error.response.status : error.message);\r\n        \r\n        // Don't retry if we got a 401 (invalid credentials)\r\n        if (error.response && error.response.status === 401) {\r\n          throw error; // Re-throw to handle invalid credentials properly\r\n        }\r\n        \r\n        // Continue to next attempt for other errors\r\n      }\r\n    }\r\n    \r\n    // If all attempts failed, throw the last error\r\n    if (!response) {\r\n      console.error('All login attempts failed');\r\n      throw lastError || new Error('Failed to connect to backend');\r\n    }\r\n    \r\n    console.log('Login response structure:', Object.keys(response.data).join(', '));\r\n    \r\n    // Extract token from various possible formats\r\n    let token = null;\r\n    \r\n    if (response.data.token) {\r\n      token = response.data.token;\r\n      console.log('Found token in response.data.token');\r\n    } else if (response.data.access) {\r\n      token = response.data.access;\r\n      console.log('Found token in response.data.access');\r\n    } else if (response.data.key) {\r\n      token = response.data.key;\r\n      console.log('Found token in response.data.key');\r\n    } else if (typeof response.data === 'string') {\r\n      // Sometimes the API returns the token directly as a string\r\n      token = response.data;\r\n      console.log('Response data is a string, using as token');\r\n    } else {\r\n      // Loop through all properties to find one that might be a token\r\n      for (const key in response.data) {\r\n        if (\r\n          typeof response.data[key] === 'string' && \r\n          (response.data[key].length > 20 || key.toLowerCase().includes('token'))\r\n        ) {\r\n          token = response.data[key];\r\n          console.log(`Found possible token in response.data.${key}`);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (!token) {\r\n      console.error('No token found in login response:', response.data);\r\n      throw new Error('Authentication failed: No token in response');\r\n    }\r\n    \r\n    // Log details about the token to help with debugging\r\n    console.log('Token length:', token.length);\r\n    console.log('Token starts with:', token.substring(0, 10) + '...');\r\n    console.log('Appears to be JWT:', token.startsWith('eyJ'));\r\n    \r\n    // Store the token\r\n    localStorage.setItem('token', token);\r\n    \r\n    // Store user info if available in the response\r\n    if (response.data.user) {\r\n      console.log('User data found in response:', Object.keys(response.data.user).join(', '));\r\n      const userData = response.data.user;\r\n      \r\n      if (userData.email) {\r\n        sessionStorage.setItem('lastLoginEmail', userData.email);\r\n      } else if (typeof email === 'string') {\r\n        sessionStorage.setItem('lastLoginEmail', email);\r\n      }\r\n      \r\n      if (userData.name) {\r\n        sessionStorage.setItem('userName', userData.name);\r\n      } else if (userData.username) {\r\n        sessionStorage.setItem('userName', userData.username);\r\n      } else if (userData.first_name) {\r\n        const fullName = userData.last_name \r\n          ? `${userData.first_name} ${userData.last_name}`\r\n          : userData.first_name;\r\n        sessionStorage.setItem('userName', fullName);\r\n      } else if (userData.id) {\r\n        // If we only have user ID, store that\r\n        sessionStorage.setItem('userId', userData.id.toString());\r\n      }\r\n    } else {\r\n      // If we don't have user info, store the email we logged in with\r\n      if (typeof email === 'string') {\r\n        sessionStorage.setItem('lastLoginEmail', email);\r\n        \r\n        // Extract username from email for a fallback user name\r\n        const username = email.split('@')[0];\r\n        if (username) {\r\n          // Capitalize first letter of username for better display\r\n          const displayName = username.charAt(0).toUpperCase() + username.slice(1);\r\n          sessionStorage.setItem('userName', displayName);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return {\r\n      ...response.data,\r\n      token: token, // Ensure token is in the returned data\r\n      success: true\r\n    };\r\n  } catch (error) {\r\n    console.error('Login error:', error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const signupUser = async (userData) => {\r\n  try {\r\n    const response = await api.post('/api/auth/signup/', userData);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error('API: Signup error:', error.message);\r\n    throw new Error(error.response?.data?.message || 'Signup failed. Please try again.');\r\n  }\r\n};\r\n\r\n// User profile\r\nexport const getUserProfile = async () => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    if (!token) {\r\n      throw new Error('Authentication required');\r\n    }\r\n\r\n    // Determine the correct authentication header based on token format\r\n    let headers = {};\r\n    if (token.startsWith('eyJ')) {\r\n      // Looks like a JWT token\r\n      headers.Authorization = `Bearer ${token}`;\r\n      console.log('getUserProfile: Using Bearer format for JWT token');\r\n    } else {\r\n      // Use Token format for other types\r\n      headers.Authorization = `Token ${token}`;\r\n      console.log('getUserProfile: Using Django REST Framework Token format');\r\n    }\r\n\r\n    // Try multiple profile endpoints that might exist\r\n    const possibleEndpoints = [\r\n      '/apiV1/profile/',\r\n      '/apiV1/user/profile/',\r\n      '/apiV1/user/',\r\n      '/api/auth/profile/',\r\n      '/api/auth/user/',\r\n      '/api/user/profile/',\r\n      '/api/user/',\r\n      '/api/profile/',\r\n      '/api/me/',\r\n      '/admin/'  // Try admin endpoint as a test for authentication\r\n    ];\r\n    \r\n    let lastError = null;\r\n    let userData = null;\r\n    \r\n    // Try each endpoint until one works\r\n    for (const endpoint of possibleEndpoints) {\r\n      try {\r\n        console.log(`Trying to fetch profile from ${endpoint}`);\r\n        const response = await api.get(endpoint, { headers });\r\n        \r\n        if (response.status === 200 && response.data) {\r\n          console.log(`Profile found at ${endpoint}:`, response.status);\r\n          userData = response.data;\r\n          break;\r\n        }\r\n      } catch (endpointError) {\r\n        console.log(`Profile not found at ${endpoint}:`, \r\n          endpointError.response ? endpointError.response.status : 'network error');\r\n        lastError = endpointError;\r\n        // Continue to the next endpoint\r\n      }\r\n    }\r\n    \r\n    // If we found user data from any endpoint\r\n    if (userData) {\r\n      console.log('Profile data found:', Object.keys(userData).join(', '));\r\n      \r\n      // Store key user info in session storage for fallback\r\n      if (userData.email) {\r\n        sessionStorage.setItem('lastLoginEmail', userData.email);\r\n      }\r\n      \r\n      if (userData.name) {\r\n        sessionStorage.setItem('userName', userData.name);\r\n      } else if (userData.username) {\r\n        sessionStorage.setItem('userName', userData.username);\r\n      } else if (userData.first_name) {\r\n        const fullName = userData.last_name \r\n          ? `${userData.first_name} ${userData.last_name}`\r\n          : userData.first_name;\r\n        sessionStorage.setItem('userName', fullName);\r\n      }\r\n      \r\n      return userData;\r\n    }\r\n    \r\n    // If we get here, no endpoints worked but we have a token\r\n    // Create a fallback profile based on stored session data\r\n    console.log('No profile endpoints successful, using fallback data');\r\n    const email = sessionStorage.getItem('lastLoginEmail');\r\n    const name = sessionStorage.getItem('userName');\r\n    \r\n    if (email) {\r\n      return {\r\n        email: email,\r\n        name: name || 'User',\r\n        profile_picture: null,\r\n      };\r\n    }\r\n    \r\n    // If we have no email, re-throw the last error\r\n    throw lastError || new Error('Failed to fetch profile from all endpoints');\r\n  } catch (error) {\r\n    console.error('Error fetching user profile:', \r\n      error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\r\n    \r\n    // Create a fallback user object if profile fetch fails\r\n    const email = sessionStorage.getItem('lastLoginEmail');\r\n    if (email) {\r\n      return {\r\n        email: email,\r\n        name: sessionStorage.getItem('userName') || 'User',\r\n        profile_picture: null,\r\n      };\r\n    }\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Directories\r\nexport const getDirectories = async () => {\r\n  try {\r\n    const token = localStorage.getItem('token');\r\n    if (!token) {\r\n      throw new Error('Authentication required');\r\n    }\r\n\r\n    // Try with trailing slash first (Django often requires this)\r\n    const response = await api.get('/apiV1/directories/', {\r\n      headers: {\r\n        Authorization: `Token ${token}`, // Using Token format for Django REST Framework\r\n      },\r\n    });\r\n\r\n    console.log('Directories response:', response.status, response.data);\r\n    return response.data;\r\n  } catch (error) {\r\n    // If we get a 404 with trailing slash, try without\r\n    if (error.response && error.response.status === 404) {\r\n      try {\r\n        const response = await api.get('/apiV1/directories', {\r\n          headers: {\r\n            Authorization: `Token ${token}`,\r\n          },\r\n        });\r\n        console.log('Directories response (without trailing slash):', response.status, response.data);\r\n        return response.data;\r\n      } catch (retryError) {\r\n        console.error('Error fetching directories (retry):', retryError.response ? retryError.response.status : retryError.message);\r\n        throw retryError;\r\n      }\r\n    }\r\n\r\n    console.error('Error fetching directories:', error.response ? error.response.status : error.message);\r\n    \r\n    // Return some mock directory data if the API fails\r\n    return [\r\n      { id: 1, name: 'Documents', path: '/documents', color: '#4285F4' },\r\n      { id: 2, name: 'Images', path: '/images', color: '#34A853' },\r\n      { id: 3, name: 'Projects', path: '/projects', color: '#FBBC05' },\r\n      { id: 4, name: 'Reports', path: '/reports', color: '#EA4335' },\r\n    ];\r\n  }\r\n};\r\n\r\n// Chat API Functions\r\nexport const getChatHistory = async () => {\r\n  try {\r\n    // Since there's no specific chat history endpoint, we'll return an empty array\r\n    // The Chat component will handle creating the initial welcome message\r\n    return [];\r\n  } catch (error) {\r\n    console.error('Error fetching chat history:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\nexport const sendChatMessage = async (message) => {\r\n  try {\r\n    // Handle test connection request\r\n    if (message === '__test_connection__') {\r\n      console.log('Testing connection to RAG pipeline...');\r\n      try {\r\n        const token = localStorage.getItem('token');\r\n        if (!token) {\r\n          return { success: false, error: 'No authentication token' };\r\n        }\r\n        \r\n        // Always use Django REST Framework Token format\r\n        const headers = { \r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Token ${token}`\r\n        };\r\n        console.log('Test connection: Using Django REST Framework Token format');\r\n        \r\n        // Try multiple endpoints to see if any respond\r\n        const testEndpoints = [\r\n          '/apiV1/chat/',\r\n          '/api/chat/',\r\n          '/apiV1/ping/',\r\n          '/api/health/',\r\n          '/'\r\n        ];\r\n        \r\n        for (const endpoint of testEndpoints) {\r\n          try {\r\n            // For the chat endpoints, use GET for connection test\r\n            console.log(`Testing connection to endpoint: ${endpoint}`);\r\n            const response = await api.get(endpoint, { headers });\r\n            \r\n            console.log(`Successfully connected to ${endpoint} (${response.status})`);\r\n            return { \r\n              success: true,\r\n              endpoint: endpoint,\r\n              message: `Connected to RAG pipeline at ${endpoint}`\r\n            };\r\n          } catch (endpointError) {\r\n            // If we get a 404, the server is up at ${endpoint} but returned 404\r\n            if (endpointError.response && endpointError.response.status === 404) {\r\n              console.log(`Server is up at ${endpoint} but returned 404`);\r\n              // Instead of treating 404 as success, track that the backend is available\r\n              // but the endpoint is missing\r\n              return { \r\n                success: false, \r\n                serverRunning: true,\r\n                endpoint: endpoint, \r\n                message: 'Backend server is running but API endpoint not found',\r\n                status: 404,\r\n                error: 'API endpoint not available'\r\n              };\r\n            }\r\n            \r\n            // If we get a 401/403, the authentication is wrong, report it specially\r\n            if (endpointError.response && (endpointError.response.status === 401 || endpointError.response.status === 403)) {\r\n              console.error(`Authentication error at ${endpoint}: ${endpointError.response.status}`);\r\n              return { \r\n                success: false, \r\n                error: 'Authentication error', \r\n                authError: true,\r\n                status: endpointError.response.status,\r\n                message: endpointError.response.data?.detail || 'Invalid authentication credentials'\r\n              };\r\n            }\r\n            \r\n            // Otherwise continue trying other endpoints\r\n            console.log(`Failed to connect to ${endpoint}: ${endpointError.message}`);\r\n          }\r\n        }\r\n        \r\n        // If all endpoints failed, return an error\r\n        return { \r\n          success: false, \r\n          error: 'Could not connect to any backend endpoints',\r\n          offline: true\r\n        };\r\n      } catch (error) {\r\n        console.error('Connection test failed:', \r\n          error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\r\n        \r\n        return { \r\n          success: false, \r\n          error: error.response ? `Server error (${error.response.status})` : 'Network error',\r\n          offline: true\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Regular message sending\r\n    const token = localStorage.getItem('token');\r\n    if (!token) {\r\n      throw new Error('Authentication required');\r\n    }\r\n    \r\n    // Always use Django REST Framework Token format\r\n    const headers = { \r\n      'Content-Type': 'application/json',\r\n      'Authorization': `Token ${token}`\r\n    };\r\n    console.log('Using Django REST Framework Token format for message');\r\n    \r\n    console.log('Sending message to RAG pipeline...');\r\n    \r\n    try {\r\n      // Try the main chat endpoint first\r\n      const response = await api.post('/apiV1/chat/', { message }, { headers });\r\n      console.log('Chat response received:', response.status);\r\n      \r\n      return {\r\n        success: true,\r\n        ai_response: response.data.response || response.data.message || response.data.reply || response.data,\r\n        sources: response.data.sources || [],\r\n      };\r\n    } catch (error) {\r\n      // If the main endpoint fails with 404, try the alternative without trailing slash\r\n      if (error.response && error.response.status === 404) {\r\n        try {\r\n          console.log('Trying alternative chat endpoint without trailing slash...');\r\n          const response = await api.post('/apiV1/chat', { message }, { headers });\r\n          console.log('Chat response received from alternative endpoint:', response.status);\r\n          \r\n          return {\r\n            success: true,\r\n            ai_response: response.data.response || response.data.message || response.data.reply || response.data,\r\n            sources: response.data.sources || [],\r\n          };\r\n        } catch (retryError) {\r\n          throw retryError; // Let the outer catch handle this\r\n        }\r\n      }\r\n      throw error; // Re-throw if not a 404\r\n    }\r\n  } catch (error) {\r\n    console.error('Chat error:', \r\n      error.response ? `${error.response.status}: ${JSON.stringify(error.response.data)}` : error.message);\r\n    \r\n    // Check specifically for authorization errors\r\n    if (error.response && (error.response.status === 401 || error.response.status === 403)) {\r\n      return { \r\n        success: false, \r\n        error: 'Authentication error', \r\n        authError: true,\r\n        status: error.response.status,\r\n        message: error.response.data?.detail || 'Invalid authentication credentials'\r\n      };\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      error: error.response ? `Server error (${error.response.status})` : 'Network error',\r\n      offline: true\r\n    };\r\n  }\r\n};\r\n\r\n// Function to diagnose API endpoints\r\nexport const checkApiEndpoints = async () => {\r\n  const token = localStorage.getItem('token');\r\n  if (!token) {\r\n    console.error('No authentication token available');\r\n    return { authenticated: false, endpoints: [] };\r\n  }\r\n  \r\n  // Prepare headers\r\n  const headers = {\r\n    Authorization: `Token ${token}`,\r\n  };\r\n  \r\n  // List of endpoints to test\r\n  const endpoints = [\r\n    // Common API endpoints\r\n    { method: 'GET', url: '/api/auth/profile/' },\r\n    { method: 'GET', url: '/api/directories/' },\r\n    { method: 'GET', url: '/api/chat/' },\r\n    { method: 'POST', url: '/api/chat/', data: { message: 'test' } },\r\n    \r\n    // V1 API endpoints \r\n    { method: 'GET', url: '/apiV1/profile/' },\r\n    { method: 'GET', url: '/apiV1/directories/' },\r\n    { method: 'GET', url: '/apiV1/ping/' },\r\n    { method: 'POST', url: '/apiV1/chat/', data: { message: 'test' } },\r\n    \r\n    // Azure-specific endpoints (if any)\r\n    { method: 'GET', url: '/apiV1/azure/status/' },\r\n  ];\r\n  \r\n  const results = [];\r\n  \r\n  // Test each endpoint\r\n  for (const endpoint of endpoints) {\r\n    try {\r\n      console.log(`Testing ${endpoint.method} ${endpoint.url}...`);\r\n      \r\n      const config = {\r\n        method: endpoint.method,\r\n        url: endpoint.url,\r\n        headers: headers,\r\n        data: endpoint.data || null\r\n      };\r\n      \r\n      const response = await axios(config);\r\n      \r\n      results.push({\r\n        endpoint: endpoint.url,\r\n        method: endpoint.method,\r\n        status: response.status,\r\n        available: true,\r\n        data: typeof response.data === 'object' ? 'Object received' : 'Data received'\r\n      });\r\n      \r\n      console.log(`✅ ${endpoint.method} ${endpoint.url} - Status: ${response.status}`);\r\n    } catch (error) {\r\n      results.push({\r\n        endpoint: endpoint.url,\r\n        method: endpoint.method,\r\n        status: error.response?.status || 'Network Error',\r\n        available: false,\r\n        error: error.response?.data || error.message\r\n      });\r\n      \r\n      console.log(`❌ ${endpoint.method} ${endpoint.url} - Error: ${error.response?.status || error.message}`);\r\n    }\r\n  }\r\n  \r\n  // Log the summary\r\n  const availableEndpoints = results.filter(e => e.available);\r\n  console.log(`API Endpoint Check Summary: ${availableEndpoints.length}/${endpoints.length} endpoints available`);\r\n  console.table(results);\r\n  \r\n  return {\r\n    authenticated: true,\r\n    endpoints: results,\r\n    availableCount: availableEndpoints.length,\r\n    totalCount: endpoints.length\r\n  };\r\n};\r\n\r\n/**\r\n * Tests a specific endpoint and returns detailed status information\r\n * @param {string} endpoint - The endpoint path to test (e.g., '/api/chat/')\r\n * @returns {Object} - Object containing status information\r\n */\r\nexport const testEndpoint = async (endpoint) => {\r\n  const baseUrl = 'http://127.0.0.1:8000'; // Django backend URL\r\n  const url = `${baseUrl}${endpoint}`;\r\n  \r\n  try {\r\n    // Get token if available and use Django REST Framework Token format\r\n    const token = localStorage.getItem('token');\r\n    const headers = token ? { 'Authorization': `Token ${token}` } : {};\r\n    \r\n    console.log(`Testing endpoint: ${url}`);\r\n    console.log('Authorization header:', token ? 'Token xxxx...' : 'None');\r\n    \r\n    // For GET endpoints\r\n    const response = await axios.get(url, { \r\n      headers,\r\n      // Don't throw error on non-2xx responses - we want to handle them ourselves\r\n      validateStatus: () => true\r\n    });\r\n    \r\n    console.log(`Endpoint ${url} response:`, response.status, response.statusText);\r\n    \r\n    // A 404 means the server is running but endpoint doesn't exist\r\n    if (response.status === 404) {\r\n      return {\r\n        url,\r\n        status: 404,\r\n        available: false,\r\n        serverRunning: true,\r\n        message: \"Endpoint not found, but server is running\",\r\n        data: response.data\r\n      };\r\n    }\r\n    \r\n    // Auth errors\r\n    if (response.status === 401 || response.status === 403) {\r\n      return {\r\n        url,\r\n        status: response.status,\r\n        available: false,\r\n        authError: true,\r\n        message: response.status === 401 ? \"Unauthorized - Invalid or missing token\" : \"Forbidden\",\r\n        data: response.data\r\n      };\r\n    }\r\n    \r\n    // Success (2xx) responses\r\n    if (response.status >= 200 && response.status < 300) {\r\n      return {\r\n        url,\r\n        status: response.status,\r\n        available: true,\r\n        message: \"Endpoint available\",\r\n        data: response.data\r\n      };\r\n    }\r\n    \r\n    // Other responses\r\n    return {\r\n      url,\r\n      status: response.status,\r\n      available: false,\r\n      message: `Endpoint responded with: ${response.status} ${response.statusText}`,\r\n      data: response.data\r\n    };\r\n  } catch (error) {\r\n    console.error(`Error testing endpoint ${url}:`, error);\r\n    \r\n    // Network errors (server not running)\r\n    if (error.code === 'ERR_NETWORK') {\r\n      return {\r\n        url,\r\n        status: 'Network Error',\r\n        available: false,\r\n        serverRunning: false,\r\n        message: \"Server not running or network error\",\r\n        error: error.message\r\n      };\r\n    }\r\n    \r\n    return {\r\n      url,\r\n      status: error.response?.status || 'Error',\r\n      available: false,\r\n      message: `Error: ${error.message}`,\r\n      error: error.message\r\n    };\r\n  }\r\n};\r\n\r\nexport default api;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;;AAEzB;AACA,MAAMC,GAAG,GAAGD,KAAK,CAACE,MAAM,CAAC;EACvBC,OAAO,EAAE,uBAAuB;EAAE;EAClCC,OAAO,EAAE;IACP,cAAc,EAAE;EAClB;AACF,CAAC,CAAC;;AAEF;AACAH,GAAG,CAACI,YAAY,CAACC,OAAO,CAACC,GAAG,CACzBC,MAAM,IAAK;EACV;EACA,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;;EAE3C;EACA,IAAIF,KAAK,EAAE;IAAA,IAAAG,qBAAA;IACTC,OAAO,CAACC,GAAG,CAAC,gCAAgCN,MAAM,CAACO,GAAG,EAAE,CAAC;;IAEzD;IACA,IAAIN,KAAK,CAACO,UAAU,CAAC,KAAK,CAAC,EAAE;MAC3B;MACAR,MAAM,CAACJ,OAAO,CAACa,aAAa,GAAG,UAAUR,KAAK,EAAE;MAChDI,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;IAClD,CAAC,MAAM;MACL;MACAN,MAAM,CAACJ,OAAO,CAACa,aAAa,GAAG,SAASR,KAAK,EAAE;MAC/CI,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;IACzD;;IAEA;IACAD,OAAO,CAACC,GAAG,CAAC,uBAAuB,EACjC,GAAGN,MAAM,CAACJ,OAAO,CAACa,aAAa,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAAN,qBAAA,GAAIJ,MAAM,CAACJ,OAAO,CAACa,aAAa,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,cAAAN,qBAAA,uBAA1CA,qBAAA,CAA4CO,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC;IACrHN,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEL,KAAK,CAACW,MAAM,CAAC;EAC5C,CAAC,MAAM;IACLP,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;EAC5C;EAEA,OAAON,MAAM;AACf,CAAC,EACAa,KAAK,IAAK;EACTR,OAAO,CAACQ,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;EAClD,OAAOC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;AACApB,GAAG,CAACI,YAAY,CAACmB,QAAQ,CAACjB,GAAG,CAC1BiB,QAAQ,IAAK;EACZ,OAAOA,QAAQ;AACjB,CAAC,EACAH,KAAK,IAAK;EACT;EACA,IAAIA,KAAK,CAACG,QAAQ,IAAIH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;IACnDZ,OAAO,CAACQ,KAAK,CAAC,kCAAkC,EAAE;MAChDN,GAAG,EAAEM,KAAK,CAACb,MAAM,CAACO,GAAG;MACrBW,MAAM,EAAEL,KAAK,CAACb,MAAM,CAACkB,MAAM;MAC3BtB,OAAO,EAAEiB,KAAK,CAACb,MAAM,CAACJ,OAAO,CAACa,aAAa,GACzCI,KAAK,CAACb,MAAM,CAACJ,OAAO,CAACa,aAAa,CAACE,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK,GAAG,MAAM;MACtEQ,IAAI,EAAEN,KAAK,CAACG,QAAQ,CAACG;IACvB,CAAC,CAAC;;IAEF;IACA,IAAIN,KAAK,CAACG,QAAQ,CAACG,IAAI,KAClBN,KAAK,CAACG,QAAQ,CAACG,IAAI,CAACC,MAAM,KAAK,eAAe,IAC9CP,KAAK,CAACG,QAAQ,CAACG,IAAI,CAACE,OAAO,KAAK,eAAe,CAAC,EAAE;MACrDhB,OAAO,CAACQ,KAAK,CAAC,yDAAyD,CAAC;;MAExE;MACA;IACF;EACF;EAEA,OAAOC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;AAC9B,CACF,CAAC;;AAED;AACA,OAAO,MAAMS,SAAS,GAAG,MAAOC,WAAW,IAAK;EAC9C,IAAI;IACFlB,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;;IAEzC;IACA,IAAIkB,KAAK,EAAEC,QAAQ;IAEnB,IAAI,OAAOF,WAAW,KAAK,QAAQ,IAAIA,WAAW,KAAK,IAAI,EAAE;MAC3D;MACAC,KAAK,GAAGD,WAAW,CAACC,KAAK;MACzBC,QAAQ,GAAGF,WAAW,CAACE,QAAQ;IACjC,CAAC,MAAM;MACL;MACApB,OAAO,CAACQ,KAAK,CAAC,6BAA6B,EAAEU,WAAW,CAAC;MACzD,MAAM,IAAIG,KAAK,CAAC,8BAA8B,CAAC;IACjD;;IAEA;IACArB,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEkB,KAAK,CAAC;;IAE7C;IACA,MAAMG,cAAc,GAAG,CACrB;MAAEC,QAAQ,EAAE,kBAAkB;MAAEC,OAAO,EAAE;QAAEL,KAAK;QAAEC;MAAS;IAAE,CAAC,EAC9D;MAAEG,QAAQ,EAAE,kBAAkB;MAAEC,OAAO,EAAE;QAAEC,QAAQ,EAAEN,KAAK;QAAEC;MAAS;IAAE,CAAC,EACxE;MAAEG,QAAQ,EAAE,aAAa;MAAEC,OAAO,EAAE;QAAEL,KAAK;QAAEC;MAAS;IAAE,CAAC,EACzD;MAAEG,QAAQ,EAAE,aAAa;MAAEC,OAAO,EAAE;QAAEC,QAAQ,EAAEN,KAAK;QAAEC;MAAS;IAAE,CAAC,EACnE;MAAEG,QAAQ,EAAE,aAAa;MAAEC,OAAO,EAAE;QAAEL,KAAK;QAAEC;MAAS;IAAE,CAAC,CAC1D;;IAED;IACA,IAAIM,SAAS,GAAG,IAAI;IACpB,IAAIf,QAAQ,GAAG,IAAI;IAEnB,KAAK,MAAMgB,OAAO,IAAIL,cAAc,EAAE;MACpC,IAAI;QACFtB,OAAO,CAACC,GAAG,CAAC,+BAA+B0B,OAAO,CAACJ,QAAQ,EAAE,CAAC;QAC9DvB,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE2B,MAAM,CAACC,IAAI,CAACF,OAAO,CAACH,OAAO,CAAC,CAACM,IAAI,CAAC,IAAI,CAAC,CAAC;QAE3EnB,QAAQ,GAAG,MAAMvB,GAAG,CAAC2C,IAAI,CAACJ,OAAO,CAACJ,QAAQ,EAAEI,OAAO,CAACH,OAAO,CAAC;QAC5DxB,OAAO,CAACC,GAAG,CAAC,yBAAyB0B,OAAO,CAACJ,QAAQ,EAAE,CAAC;QACxD,MAAM,CAAC;MACT,CAAC,CAAC,OAAOf,KAAK,EAAE;QACdkB,SAAS,GAAGlB,KAAK;QACjBR,OAAO,CAACC,GAAG,CAAC,6BAA6B0B,OAAO,CAACJ,QAAQ,GAAG,EAC1Df,KAAK,CAACG,QAAQ,GAAGH,KAAK,CAACG,QAAQ,CAACC,MAAM,GAAGJ,KAAK,CAACQ,OAAO,CAAC;;QAEzD;QACA,IAAIR,KAAK,CAACG,QAAQ,IAAIH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;UACnD,MAAMJ,KAAK,CAAC,CAAC;QACf;;QAEA;MACF;IACF;;IAEA;IACA,IAAI,CAACG,QAAQ,EAAE;MACbX,OAAO,CAACQ,KAAK,CAAC,2BAA2B,CAAC;MAC1C,MAAMkB,SAAS,IAAI,IAAIL,KAAK,CAAC,8BAA8B,CAAC;IAC9D;IAEArB,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAE2B,MAAM,CAACC,IAAI,CAAClB,QAAQ,CAACG,IAAI,CAAC,CAACgB,IAAI,CAAC,IAAI,CAAC,CAAC;;IAE/E;IACA,IAAIlC,KAAK,GAAG,IAAI;IAEhB,IAAIe,QAAQ,CAACG,IAAI,CAAClB,KAAK,EAAE;MACvBA,KAAK,GAAGe,QAAQ,CAACG,IAAI,CAAClB,KAAK;MAC3BI,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;IACnD,CAAC,MAAM,IAAIU,QAAQ,CAACG,IAAI,CAACkB,MAAM,EAAE;MAC/BpC,KAAK,GAAGe,QAAQ,CAACG,IAAI,CAACkB,MAAM;MAC5BhC,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;IACpD,CAAC,MAAM,IAAIU,QAAQ,CAACG,IAAI,CAACmB,GAAG,EAAE;MAC5BrC,KAAK,GAAGe,QAAQ,CAACG,IAAI,CAACmB,GAAG;MACzBjC,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;IACjD,CAAC,MAAM,IAAI,OAAOU,QAAQ,CAACG,IAAI,KAAK,QAAQ,EAAE;MAC5C;MACAlB,KAAK,GAAGe,QAAQ,CAACG,IAAI;MACrBd,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;IAC1D,CAAC,MAAM;MACL;MACA,KAAK,MAAMgC,GAAG,IAAItB,QAAQ,CAACG,IAAI,EAAE;QAC/B,IACE,OAAOH,QAAQ,CAACG,IAAI,CAACmB,GAAG,CAAC,KAAK,QAAQ,KACrCtB,QAAQ,CAACG,IAAI,CAACmB,GAAG,CAAC,CAAC1B,MAAM,GAAG,EAAE,IAAI0B,GAAG,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,OAAO,CAAC,CAAC,EACvE;UACAvC,KAAK,GAAGe,QAAQ,CAACG,IAAI,CAACmB,GAAG,CAAC;UAC1BjC,OAAO,CAACC,GAAG,CAAC,yCAAyCgC,GAAG,EAAE,CAAC;UAC3D;QACF;MACF;IACF;IAEA,IAAI,CAACrC,KAAK,EAAE;MACVI,OAAO,CAACQ,KAAK,CAAC,mCAAmC,EAAEG,QAAQ,CAACG,IAAI,CAAC;MACjE,MAAM,IAAIO,KAAK,CAAC,6CAA6C,CAAC;IAChE;;IAEA;IACArB,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEL,KAAK,CAACW,MAAM,CAAC;IAC1CP,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEL,KAAK,CAACU,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK,CAAC;IACjEN,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEL,KAAK,CAACO,UAAU,CAAC,KAAK,CAAC,CAAC;;IAE1D;IACAN,YAAY,CAACuC,OAAO,CAAC,OAAO,EAAExC,KAAK,CAAC;;IAEpC;IACA,IAAIe,QAAQ,CAACG,IAAI,CAACuB,IAAI,EAAE;MACtBrC,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAE2B,MAAM,CAACC,IAAI,CAAClB,QAAQ,CAACG,IAAI,CAACuB,IAAI,CAAC,CAACP,IAAI,CAAC,IAAI,CAAC,CAAC;MACvF,MAAMQ,QAAQ,GAAG3B,QAAQ,CAACG,IAAI,CAACuB,IAAI;MAEnC,IAAIC,QAAQ,CAACnB,KAAK,EAAE;QAClBoB,cAAc,CAACH,OAAO,CAAC,gBAAgB,EAAEE,QAAQ,CAACnB,KAAK,CAAC;MAC1D,CAAC,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;QACpCoB,cAAc,CAACH,OAAO,CAAC,gBAAgB,EAAEjB,KAAK,CAAC;MACjD;MAEA,IAAImB,QAAQ,CAACE,IAAI,EAAE;QACjBD,cAAc,CAACH,OAAO,CAAC,UAAU,EAAEE,QAAQ,CAACE,IAAI,CAAC;MACnD,CAAC,MAAM,IAAIF,QAAQ,CAACb,QAAQ,EAAE;QAC5Bc,cAAc,CAACH,OAAO,CAAC,UAAU,EAAEE,QAAQ,CAACb,QAAQ,CAAC;MACvD,CAAC,MAAM,IAAIa,QAAQ,CAACG,UAAU,EAAE;QAC9B,MAAMC,QAAQ,GAAGJ,QAAQ,CAACK,SAAS,GAC/B,GAAGL,QAAQ,CAACG,UAAU,IAAIH,QAAQ,CAACK,SAAS,EAAE,GAC9CL,QAAQ,CAACG,UAAU;QACvBF,cAAc,CAACH,OAAO,CAAC,UAAU,EAAEM,QAAQ,CAAC;MAC9C,CAAC,MAAM,IAAIJ,QAAQ,CAACM,EAAE,EAAE;QACtB;QACAL,cAAc,CAACH,OAAO,CAAC,QAAQ,EAAEE,QAAQ,CAACM,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC;MAC1D;IACF,CAAC,MAAM;MACL;MACA,IAAI,OAAO1B,KAAK,KAAK,QAAQ,EAAE;QAC7BoB,cAAc,CAACH,OAAO,CAAC,gBAAgB,EAAEjB,KAAK,CAAC;;QAE/C;QACA,MAAMM,QAAQ,GAAGN,KAAK,CAACd,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QACpC,IAAIoB,QAAQ,EAAE;UACZ;UACA,MAAMqB,WAAW,GAAGrB,QAAQ,CAACsB,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGvB,QAAQ,CAACwB,KAAK,CAAC,CAAC,CAAC;UACxEV,cAAc,CAACH,OAAO,CAAC,UAAU,EAAEU,WAAW,CAAC;QACjD;MACF;IACF;IAEA,OAAO;MACL,GAAGnC,QAAQ,CAACG,IAAI;MAChBlB,KAAK,EAAEA,KAAK;MAAE;MACdsD,OAAO,EAAE;IACX,CAAC;EACH,CAAC,CAAC,OAAO1C,KAAK,EAAE;IACdR,OAAO,CAACQ,KAAK,CAAC,cAAc,EAAEA,KAAK,CAACG,QAAQ,GAAG,GAAGH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAKuC,IAAI,CAACC,SAAS,CAAC5C,KAAK,CAACG,QAAQ,CAACG,IAAI,CAAC,EAAE,GAAGN,KAAK,CAACQ,OAAO,CAAC;IAClI,MAAMR,KAAK;EACb;AACF,CAAC;AAED,OAAO,MAAM6C,UAAU,GAAG,MAAOf,QAAQ,IAAK;EAC5C,IAAI;IACF,MAAM3B,QAAQ,GAAG,MAAMvB,GAAG,CAAC2C,IAAI,CAAC,mBAAmB,EAAEO,QAAQ,CAAC;IAC9D,OAAO3B,QAAQ,CAACG,IAAI;EACtB,CAAC,CAAC,OAAON,KAAK,EAAE;IAAA,IAAA8C,eAAA,EAAAC,oBAAA;IACdvD,OAAO,CAACQ,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAACQ,OAAO,CAAC;IAClD,MAAM,IAAIK,KAAK,CAAC,EAAAiC,eAAA,GAAA9C,KAAK,CAACG,QAAQ,cAAA2C,eAAA,wBAAAC,oBAAA,GAAdD,eAAA,CAAgBxC,IAAI,cAAAyC,oBAAA,uBAApBA,oBAAA,CAAsBvC,OAAO,KAAI,kCAAkC,CAAC;EACtF;AACF,CAAC;;AAED;AACA,OAAO,MAAMwC,cAAc,GAAG,MAAAA,CAAA,KAAY;EACxC,IAAI;IACF,MAAM5D,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACF,KAAK,EAAE;MACV,MAAM,IAAIyB,KAAK,CAAC,yBAAyB,CAAC;IAC5C;;IAEA;IACA,IAAI9B,OAAO,GAAG,CAAC,CAAC;IAChB,IAAIK,KAAK,CAACO,UAAU,CAAC,KAAK,CAAC,EAAE;MAC3B;MACAZ,OAAO,CAACa,aAAa,GAAG,UAAUR,KAAK,EAAE;MACzCI,OAAO,CAACC,GAAG,CAAC,mDAAmD,CAAC;IAClE,CAAC,MAAM;MACL;MACAV,OAAO,CAACa,aAAa,GAAG,SAASR,KAAK,EAAE;MACxCI,OAAO,CAACC,GAAG,CAAC,0DAA0D,CAAC;IACzE;;IAEA;IACA,MAAMwD,iBAAiB,GAAG,CACxB,iBAAiB,EACjB,sBAAsB,EACtB,cAAc,EACd,oBAAoB,EACpB,iBAAiB,EACjB,oBAAoB,EACpB,YAAY,EACZ,eAAe,EACf,UAAU,EACV,SAAS,CAAE;IAAA,CACZ;IAED,IAAI/B,SAAS,GAAG,IAAI;IACpB,IAAIY,QAAQ,GAAG,IAAI;;IAEnB;IACA,KAAK,MAAMf,QAAQ,IAAIkC,iBAAiB,EAAE;MACxC,IAAI;QACFzD,OAAO,CAACC,GAAG,CAAC,gCAAgCsB,QAAQ,EAAE,CAAC;QACvD,MAAMZ,QAAQ,GAAG,MAAMvB,GAAG,CAACsE,GAAG,CAACnC,QAAQ,EAAE;UAAEhC;QAAQ,CAAC,CAAC;QAErD,IAAIoB,QAAQ,CAACC,MAAM,KAAK,GAAG,IAAID,QAAQ,CAACG,IAAI,EAAE;UAC5Cd,OAAO,CAACC,GAAG,CAAC,oBAAoBsB,QAAQ,GAAG,EAAEZ,QAAQ,CAACC,MAAM,CAAC;UAC7D0B,QAAQ,GAAG3B,QAAQ,CAACG,IAAI;UACxB;QACF;MACF,CAAC,CAAC,OAAO6C,aAAa,EAAE;QACtB3D,OAAO,CAACC,GAAG,CAAC,wBAAwBsB,QAAQ,GAAG,EAC7CoC,aAAa,CAAChD,QAAQ,GAAGgD,aAAa,CAAChD,QAAQ,CAACC,MAAM,GAAG,eAAe,CAAC;QAC3Ec,SAAS,GAAGiC,aAAa;QACzB;MACF;IACF;;IAEA;IACA,IAAIrB,QAAQ,EAAE;MACZtC,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE2B,MAAM,CAACC,IAAI,CAACS,QAAQ,CAAC,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC;;MAEpE;MACA,IAAIQ,QAAQ,CAACnB,KAAK,EAAE;QAClBoB,cAAc,CAACH,OAAO,CAAC,gBAAgB,EAAEE,QAAQ,CAACnB,KAAK,CAAC;MAC1D;MAEA,IAAImB,QAAQ,CAACE,IAAI,EAAE;QACjBD,cAAc,CAACH,OAAO,CAAC,UAAU,EAAEE,QAAQ,CAACE,IAAI,CAAC;MACnD,CAAC,MAAM,IAAIF,QAAQ,CAACb,QAAQ,EAAE;QAC5Bc,cAAc,CAACH,OAAO,CAAC,UAAU,EAAEE,QAAQ,CAACb,QAAQ,CAAC;MACvD,CAAC,MAAM,IAAIa,QAAQ,CAACG,UAAU,EAAE;QAC9B,MAAMC,QAAQ,GAAGJ,QAAQ,CAACK,SAAS,GAC/B,GAAGL,QAAQ,CAACG,UAAU,IAAIH,QAAQ,CAACK,SAAS,EAAE,GAC9CL,QAAQ,CAACG,UAAU;QACvBF,cAAc,CAACH,OAAO,CAAC,UAAU,EAAEM,QAAQ,CAAC;MAC9C;MAEA,OAAOJ,QAAQ;IACjB;;IAEA;IACA;IACAtC,OAAO,CAACC,GAAG,CAAC,sDAAsD,CAAC;IACnE,MAAMkB,KAAK,GAAGoB,cAAc,CAACzC,OAAO,CAAC,gBAAgB,CAAC;IACtD,MAAM0C,IAAI,GAAGD,cAAc,CAACzC,OAAO,CAAC,UAAU,CAAC;IAE/C,IAAIqB,KAAK,EAAE;MACT,OAAO;QACLA,KAAK,EAAEA,KAAK;QACZqB,IAAI,EAAEA,IAAI,IAAI,MAAM;QACpBoB,eAAe,EAAE;MACnB,CAAC;IACH;;IAEA;IACA,MAAMlC,SAAS,IAAI,IAAIL,KAAK,CAAC,4CAA4C,CAAC;EAC5E,CAAC,CAAC,OAAOb,KAAK,EAAE;IACdR,OAAO,CAACQ,KAAK,CAAC,8BAA8B,EAC1CA,KAAK,CAACG,QAAQ,GAAG,GAAGH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAKuC,IAAI,CAACC,SAAS,CAAC5C,KAAK,CAACG,QAAQ,CAACG,IAAI,CAAC,EAAE,GAAGN,KAAK,CAACQ,OAAO,CAAC;;IAEtG;IACA,MAAMG,KAAK,GAAGoB,cAAc,CAACzC,OAAO,CAAC,gBAAgB,CAAC;IACtD,IAAIqB,KAAK,EAAE;MACT,OAAO;QACLA,KAAK,EAAEA,KAAK;QACZqB,IAAI,EAAED,cAAc,CAACzC,OAAO,CAAC,UAAU,CAAC,IAAI,MAAM;QAClD8D,eAAe,EAAE;MACnB,CAAC;IACH;IACA,MAAMpD,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAMqD,cAAc,GAAG,MAAAA,CAAA,KAAY;EACxC,IAAI;IACF,MAAMjE,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACF,KAAK,EAAE;MACV,MAAM,IAAIyB,KAAK,CAAC,yBAAyB,CAAC;IAC5C;;IAEA;IACA,MAAMV,QAAQ,GAAG,MAAMvB,GAAG,CAACsE,GAAG,CAAC,qBAAqB,EAAE;MACpDnE,OAAO,EAAE;QACPa,aAAa,EAAE,SAASR,KAAK,EAAE,CAAE;MACnC;IACF,CAAC,CAAC;IAEFI,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEU,QAAQ,CAACC,MAAM,EAAED,QAAQ,CAACG,IAAI,CAAC;IACpE,OAAOH,QAAQ,CAACG,IAAI;EACtB,CAAC,CAAC,OAAON,KAAK,EAAE;IACd;IACA,IAAIA,KAAK,CAACG,QAAQ,IAAIH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;MACnD,IAAI;QACF,MAAMD,QAAQ,GAAG,MAAMvB,GAAG,CAACsE,GAAG,CAAC,oBAAoB,EAAE;UACnDnE,OAAO,EAAE;YACPa,aAAa,EAAE,SAASR,KAAK;UAC/B;QACF,CAAC,CAAC;QACFI,OAAO,CAACC,GAAG,CAAC,gDAAgD,EAAEU,QAAQ,CAACC,MAAM,EAAED,QAAQ,CAACG,IAAI,CAAC;QAC7F,OAAOH,QAAQ,CAACG,IAAI;MACtB,CAAC,CAAC,OAAOgD,UAAU,EAAE;QACnB9D,OAAO,CAACQ,KAAK,CAAC,qCAAqC,EAAEsD,UAAU,CAACnD,QAAQ,GAAGmD,UAAU,CAACnD,QAAQ,CAACC,MAAM,GAAGkD,UAAU,CAAC9C,OAAO,CAAC;QAC3H,MAAM8C,UAAU;MAClB;IACF;IAEA9D,OAAO,CAACQ,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAACG,QAAQ,GAAGH,KAAK,CAACG,QAAQ,CAACC,MAAM,GAAGJ,KAAK,CAACQ,OAAO,CAAC;;IAEpG;IACA,OAAO,CACL;MAAE4B,EAAE,EAAE,CAAC;MAAEJ,IAAI,EAAE,WAAW;MAAEuB,IAAI,EAAE,YAAY;MAAEC,KAAK,EAAE;IAAU,CAAC,EAClE;MAAEpB,EAAE,EAAE,CAAC;MAAEJ,IAAI,EAAE,QAAQ;MAAEuB,IAAI,EAAE,SAAS;MAAEC,KAAK,EAAE;IAAU,CAAC,EAC5D;MAAEpB,EAAE,EAAE,CAAC;MAAEJ,IAAI,EAAE,UAAU;MAAEuB,IAAI,EAAE,WAAW;MAAEC,KAAK,EAAE;IAAU,CAAC,EAChE;MAAEpB,EAAE,EAAE,CAAC;MAAEJ,IAAI,EAAE,SAAS;MAAEuB,IAAI,EAAE,UAAU;MAAEC,KAAK,EAAE;IAAU,CAAC,CAC/D;EACH;AACF,CAAC;;AAED;AACA,OAAO,MAAMC,cAAc,GAAG,MAAAA,CAAA,KAAY;EACxC,IAAI;IACF;IACA;IACA,OAAO,EAAE;EACX,CAAC,CAAC,OAAOzD,KAAK,EAAE;IACdR,OAAO,CAACQ,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACpD,OAAO,EAAE;EACX;AACF,CAAC;AAED,OAAO,MAAM0D,eAAe,GAAG,MAAOlD,OAAO,IAAK;EAChD,IAAI;IACF;IACA,IAAIA,OAAO,KAAK,qBAAqB,EAAE;MACrChB,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;MACpD,IAAI;QACF,MAAML,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;QAC3C,IAAI,CAACF,KAAK,EAAE;UACV,OAAO;YAAEsD,OAAO,EAAE,KAAK;YAAE1C,KAAK,EAAE;UAA0B,CAAC;QAC7D;;QAEA;QACA,MAAMjB,OAAO,GAAG;UACd,cAAc,EAAE,kBAAkB;UAClC,eAAe,EAAE,SAASK,KAAK;QACjC,CAAC;QACDI,OAAO,CAACC,GAAG,CAAC,2DAA2D,CAAC;;QAExE;QACA,MAAMkE,aAAa,GAAG,CACpB,cAAc,EACd,YAAY,EACZ,cAAc,EACd,cAAc,EACd,GAAG,CACJ;QAED,KAAK,MAAM5C,QAAQ,IAAI4C,aAAa,EAAE;UACpC,IAAI;YACF;YACAnE,OAAO,CAACC,GAAG,CAAC,mCAAmCsB,QAAQ,EAAE,CAAC;YAC1D,MAAMZ,QAAQ,GAAG,MAAMvB,GAAG,CAACsE,GAAG,CAACnC,QAAQ,EAAE;cAAEhC;YAAQ,CAAC,CAAC;YAErDS,OAAO,CAACC,GAAG,CAAC,6BAA6BsB,QAAQ,KAAKZ,QAAQ,CAACC,MAAM,GAAG,CAAC;YACzE,OAAO;cACLsC,OAAO,EAAE,IAAI;cACb3B,QAAQ,EAAEA,QAAQ;cAClBP,OAAO,EAAE,gCAAgCO,QAAQ;YACnD,CAAC;UACH,CAAC,CAAC,OAAOoC,aAAa,EAAE;YACtB;YACA,IAAIA,aAAa,CAAChD,QAAQ,IAAIgD,aAAa,CAAChD,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;cACnEZ,OAAO,CAACC,GAAG,CAAC,mBAAmBsB,QAAQ,mBAAmB,CAAC;cAC3D;cACA;cACA,OAAO;gBACL2B,OAAO,EAAE,KAAK;gBACdkB,aAAa,EAAE,IAAI;gBACnB7C,QAAQ,EAAEA,QAAQ;gBAClBP,OAAO,EAAE,sDAAsD;gBAC/DJ,MAAM,EAAE,GAAG;gBACXJ,KAAK,EAAE;cACT,CAAC;YACH;;YAEA;YACA,IAAImD,aAAa,CAAChD,QAAQ,KAAKgD,aAAa,CAAChD,QAAQ,CAACC,MAAM,KAAK,GAAG,IAAI+C,aAAa,CAAChD,QAAQ,CAACC,MAAM,KAAK,GAAG,CAAC,EAAE;cAAA,IAAAyD,qBAAA;cAC9GrE,OAAO,CAACQ,KAAK,CAAC,2BAA2Be,QAAQ,KAAKoC,aAAa,CAAChD,QAAQ,CAACC,MAAM,EAAE,CAAC;cACtF,OAAO;gBACLsC,OAAO,EAAE,KAAK;gBACd1C,KAAK,EAAE,sBAAsB;gBAC7B8D,SAAS,EAAE,IAAI;gBACf1D,MAAM,EAAE+C,aAAa,CAAChD,QAAQ,CAACC,MAAM;gBACrCI,OAAO,EAAE,EAAAqD,qBAAA,GAAAV,aAAa,CAAChD,QAAQ,CAACG,IAAI,cAAAuD,qBAAA,uBAA3BA,qBAAA,CAA6BtD,MAAM,KAAI;cAClD,CAAC;YACH;;YAEA;YACAf,OAAO,CAACC,GAAG,CAAC,wBAAwBsB,QAAQ,KAAKoC,aAAa,CAAC3C,OAAO,EAAE,CAAC;UAC3E;QACF;;QAEA;QACA,OAAO;UACLkC,OAAO,EAAE,KAAK;UACd1C,KAAK,EAAE,4CAA4C;UACnD+D,OAAO,EAAE;QACX,CAAC;MACH,CAAC,CAAC,OAAO/D,KAAK,EAAE;QACdR,OAAO,CAACQ,KAAK,CAAC,yBAAyB,EACrCA,KAAK,CAACG,QAAQ,GAAG,GAAGH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAKuC,IAAI,CAACC,SAAS,CAAC5C,KAAK,CAACG,QAAQ,CAACG,IAAI,CAAC,EAAE,GAAGN,KAAK,CAACQ,OAAO,CAAC;QAEtG,OAAO;UACLkC,OAAO,EAAE,KAAK;UACd1C,KAAK,EAAEA,KAAK,CAACG,QAAQ,GAAG,iBAAiBH,KAAK,CAACG,QAAQ,CAACC,MAAM,GAAG,GAAG,eAAe;UACnF2D,OAAO,EAAE;QACX,CAAC;MACH;IACF;;IAEA;IACA,MAAM3E,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;IAC3C,IAAI,CAACF,KAAK,EAAE;MACV,MAAM,IAAIyB,KAAK,CAAC,yBAAyB,CAAC;IAC5C;;IAEA;IACA,MAAM9B,OAAO,GAAG;MACd,cAAc,EAAE,kBAAkB;MAClC,eAAe,EAAE,SAASK,KAAK;IACjC,CAAC;IACDI,OAAO,CAACC,GAAG,CAAC,sDAAsD,CAAC;IAEnED,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;IAEjD,IAAI;MACF;MACA,MAAMU,QAAQ,GAAG,MAAMvB,GAAG,CAAC2C,IAAI,CAAC,cAAc,EAAE;QAAEf;MAAQ,CAAC,EAAE;QAAEzB;MAAQ,CAAC,CAAC;MACzES,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEU,QAAQ,CAACC,MAAM,CAAC;MAEvD,OAAO;QACLsC,OAAO,EAAE,IAAI;QACbsB,WAAW,EAAE7D,QAAQ,CAACG,IAAI,CAACH,QAAQ,IAAIA,QAAQ,CAACG,IAAI,CAACE,OAAO,IAAIL,QAAQ,CAACG,IAAI,CAAC2D,KAAK,IAAI9D,QAAQ,CAACG,IAAI;QACpG4D,OAAO,EAAE/D,QAAQ,CAACG,IAAI,CAAC4D,OAAO,IAAI;MACpC,CAAC;IACH,CAAC,CAAC,OAAOlE,KAAK,EAAE;MACd;MACA,IAAIA,KAAK,CAACG,QAAQ,IAAIH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;QACnD,IAAI;UACFZ,OAAO,CAACC,GAAG,CAAC,4DAA4D,CAAC;UACzE,MAAMU,QAAQ,GAAG,MAAMvB,GAAG,CAAC2C,IAAI,CAAC,aAAa,EAAE;YAAEf;UAAQ,CAAC,EAAE;YAAEzB;UAAQ,CAAC,CAAC;UACxES,OAAO,CAACC,GAAG,CAAC,mDAAmD,EAAEU,QAAQ,CAACC,MAAM,CAAC;UAEjF,OAAO;YACLsC,OAAO,EAAE,IAAI;YACbsB,WAAW,EAAE7D,QAAQ,CAACG,IAAI,CAACH,QAAQ,IAAIA,QAAQ,CAACG,IAAI,CAACE,OAAO,IAAIL,QAAQ,CAACG,IAAI,CAAC2D,KAAK,IAAI9D,QAAQ,CAACG,IAAI;YACpG4D,OAAO,EAAE/D,QAAQ,CAACG,IAAI,CAAC4D,OAAO,IAAI;UACpC,CAAC;QACH,CAAC,CAAC,OAAOZ,UAAU,EAAE;UACnB,MAAMA,UAAU,CAAC,CAAC;QACpB;MACF;MACA,MAAMtD,KAAK,CAAC,CAAC;IACf;EACF,CAAC,CAAC,OAAOA,KAAK,EAAE;IACdR,OAAO,CAACQ,KAAK,CAAC,aAAa,EACzBA,KAAK,CAACG,QAAQ,GAAG,GAAGH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAKuC,IAAI,CAACC,SAAS,CAAC5C,KAAK,CAACG,QAAQ,CAACG,IAAI,CAAC,EAAE,GAAGN,KAAK,CAACQ,OAAO,CAAC;;IAEtG;IACA,IAAIR,KAAK,CAACG,QAAQ,KAAKH,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAK,GAAG,IAAIJ,KAAK,CAACG,QAAQ,CAACC,MAAM,KAAK,GAAG,CAAC,EAAE;MAAA,IAAA+D,qBAAA;MACtF,OAAO;QACLzB,OAAO,EAAE,KAAK;QACd1C,KAAK,EAAE,sBAAsB;QAC7B8D,SAAS,EAAE,IAAI;QACf1D,MAAM,EAAEJ,KAAK,CAACG,QAAQ,CAACC,MAAM;QAC7BI,OAAO,EAAE,EAAA2D,qBAAA,GAAAnE,KAAK,CAACG,QAAQ,CAACG,IAAI,cAAA6D,qBAAA,uBAAnBA,qBAAA,CAAqB5D,MAAM,KAAI;MAC1C,CAAC;IACH;IAEA,OAAO;MACLmC,OAAO,EAAE,KAAK;MACd1C,KAAK,EAAEA,KAAK,CAACG,QAAQ,GAAG,iBAAiBH,KAAK,CAACG,QAAQ,CAACC,MAAM,GAAG,GAAG,eAAe;MACnF2D,OAAO,EAAE;IACX,CAAC;EACH;AACF,CAAC;;AAED;AACA,OAAO,MAAMK,iBAAiB,GAAG,MAAAA,CAAA,KAAY;EAC3C,MAAMhF,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;EAC3C,IAAI,CAACF,KAAK,EAAE;IACVI,OAAO,CAACQ,KAAK,CAAC,mCAAmC,CAAC;IAClD,OAAO;MAAEqE,aAAa,EAAE,KAAK;MAAEC,SAAS,EAAE;IAAG,CAAC;EAChD;;EAEA;EACA,MAAMvF,OAAO,GAAG;IACda,aAAa,EAAE,SAASR,KAAK;EAC/B,CAAC;;EAED;EACA,MAAMkF,SAAS,GAAG;EAChB;EACA;IAAEjE,MAAM,EAAE,KAAK;IAAEX,GAAG,EAAE;EAAqB,CAAC,EAC5C;IAAEW,MAAM,EAAE,KAAK;IAAEX,GAAG,EAAE;EAAoB,CAAC,EAC3C;IAAEW,MAAM,EAAE,KAAK;IAAEX,GAAG,EAAE;EAAa,CAAC,EACpC;IAAEW,MAAM,EAAE,MAAM;IAAEX,GAAG,EAAE,YAAY;IAAEY,IAAI,EAAE;MAAEE,OAAO,EAAE;IAAO;EAAE,CAAC;EAEhE;EACA;IAAEH,MAAM,EAAE,KAAK;IAAEX,GAAG,EAAE;EAAkB,CAAC,EACzC;IAAEW,MAAM,EAAE,KAAK;IAAEX,GAAG,EAAE;EAAsB,CAAC,EAC7C;IAAEW,MAAM,EAAE,KAAK;IAAEX,GAAG,EAAE;EAAe,CAAC,EACtC;IAAEW,MAAM,EAAE,MAAM;IAAEX,GAAG,EAAE,cAAc;IAAEY,IAAI,EAAE;MAAEE,OAAO,EAAE;IAAO;EAAE,CAAC;EAElE;EACA;IAAEH,MAAM,EAAE,KAAK;IAAEX,GAAG,EAAE;EAAuB,CAAC,CAC/C;EAED,MAAM6E,OAAO,GAAG,EAAE;;EAElB;EACA,KAAK,MAAMxD,QAAQ,IAAIuD,SAAS,EAAE;IAChC,IAAI;MACF9E,OAAO,CAACC,GAAG,CAAC,WAAWsB,QAAQ,CAACV,MAAM,IAAIU,QAAQ,CAACrB,GAAG,KAAK,CAAC;MAE5D,MAAMP,MAAM,GAAG;QACbkB,MAAM,EAAEU,QAAQ,CAACV,MAAM;QACvBX,GAAG,EAAEqB,QAAQ,CAACrB,GAAG;QACjBX,OAAO,EAAEA,OAAO;QAChBuB,IAAI,EAAES,QAAQ,CAACT,IAAI,IAAI;MACzB,CAAC;MAED,MAAMH,QAAQ,GAAG,MAAMxB,KAAK,CAACQ,MAAM,CAAC;MAEpCoF,OAAO,CAACC,IAAI,CAAC;QACXzD,QAAQ,EAAEA,QAAQ,CAACrB,GAAG;QACtBW,MAAM,EAAEU,QAAQ,CAACV,MAAM;QACvBD,MAAM,EAAED,QAAQ,CAACC,MAAM;QACvBqE,SAAS,EAAE,IAAI;QACfnE,IAAI,EAAE,OAAOH,QAAQ,CAACG,IAAI,KAAK,QAAQ,GAAG,iBAAiB,GAAG;MAChE,CAAC,CAAC;MAEFd,OAAO,CAACC,GAAG,CAAC,KAAKsB,QAAQ,CAACV,MAAM,IAAIU,QAAQ,CAACrB,GAAG,cAAcS,QAAQ,CAACC,MAAM,EAAE,CAAC;IAClF,CAAC,CAAC,OAAOJ,KAAK,EAAE;MAAA,IAAA0E,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA;MACdL,OAAO,CAACC,IAAI,CAAC;QACXzD,QAAQ,EAAEA,QAAQ,CAACrB,GAAG;QACtBW,MAAM,EAAEU,QAAQ,CAACV,MAAM;QACvBD,MAAM,EAAE,EAAAsE,gBAAA,GAAA1E,KAAK,CAACG,QAAQ,cAAAuE,gBAAA,uBAAdA,gBAAA,CAAgBtE,MAAM,KAAI,eAAe;QACjDqE,SAAS,EAAE,KAAK;QAChBzE,KAAK,EAAE,EAAA2E,gBAAA,GAAA3E,KAAK,CAACG,QAAQ,cAAAwE,gBAAA,uBAAdA,gBAAA,CAAgBrE,IAAI,KAAIN,KAAK,CAACQ;MACvC,CAAC,CAAC;MAEFhB,OAAO,CAACC,GAAG,CAAC,KAAKsB,QAAQ,CAACV,MAAM,IAAIU,QAAQ,CAACrB,GAAG,aAAa,EAAAkF,gBAAA,GAAA5E,KAAK,CAACG,QAAQ,cAAAyE,gBAAA,uBAAdA,gBAAA,CAAgBxE,MAAM,KAAIJ,KAAK,CAACQ,OAAO,EAAE,CAAC;IACzG;EACF;;EAEA;EACA,MAAMqE,kBAAkB,GAAGN,OAAO,CAACO,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACN,SAAS,CAAC;EAC3DjF,OAAO,CAACC,GAAG,CAAC,+BAA+BoF,kBAAkB,CAAC9E,MAAM,IAAIuE,SAAS,CAACvE,MAAM,sBAAsB,CAAC;EAC/GP,OAAO,CAACwF,KAAK,CAACT,OAAO,CAAC;EAEtB,OAAO;IACLF,aAAa,EAAE,IAAI;IACnBC,SAAS,EAAEC,OAAO;IAClBU,cAAc,EAAEJ,kBAAkB,CAAC9E,MAAM;IACzCmF,UAAU,EAAEZ,SAAS,CAACvE;EACxB,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMoF,YAAY,GAAG,MAAOpE,QAAQ,IAAK;EAC9C,MAAMqE,OAAO,GAAG,uBAAuB,CAAC,CAAC;EACzC,MAAM1F,GAAG,GAAG,GAAG0F,OAAO,GAAGrE,QAAQ,EAAE;EAEnC,IAAI;IACF;IACA,MAAM3B,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;IAC3C,MAAMP,OAAO,GAAGK,KAAK,GAAG;MAAE,eAAe,EAAE,SAASA,KAAK;IAAG,CAAC,GAAG,CAAC,CAAC;IAElEI,OAAO,CAACC,GAAG,CAAC,qBAAqBC,GAAG,EAAE,CAAC;IACvCF,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEL,KAAK,GAAG,eAAe,GAAG,MAAM,CAAC;;IAEtE;IACA,MAAMe,QAAQ,GAAG,MAAMxB,KAAK,CAACuE,GAAG,CAACxD,GAAG,EAAE;MACpCX,OAAO;MACP;MACAsG,cAAc,EAAEA,CAAA,KAAM;IACxB,CAAC,CAAC;IAEF7F,OAAO,CAACC,GAAG,CAAC,YAAYC,GAAG,YAAY,EAAES,QAAQ,CAACC,MAAM,EAAED,QAAQ,CAACmF,UAAU,CAAC;;IAE9E;IACA,IAAInF,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;MAC3B,OAAO;QACLV,GAAG;QACHU,MAAM,EAAE,GAAG;QACXqE,SAAS,EAAE,KAAK;QAChBb,aAAa,EAAE,IAAI;QACnBpD,OAAO,EAAE,2CAA2C;QACpDF,IAAI,EAAEH,QAAQ,CAACG;MACjB,CAAC;IACH;;IAEA;IACA,IAAIH,QAAQ,CAACC,MAAM,KAAK,GAAG,IAAID,QAAQ,CAACC,MAAM,KAAK,GAAG,EAAE;MACtD,OAAO;QACLV,GAAG;QACHU,MAAM,EAAED,QAAQ,CAACC,MAAM;QACvBqE,SAAS,EAAE,KAAK;QAChBX,SAAS,EAAE,IAAI;QACftD,OAAO,EAAEL,QAAQ,CAACC,MAAM,KAAK,GAAG,GAAG,yCAAyC,GAAG,WAAW;QAC1FE,IAAI,EAAEH,QAAQ,CAACG;MACjB,CAAC;IACH;;IAEA;IACA,IAAIH,QAAQ,CAACC,MAAM,IAAI,GAAG,IAAID,QAAQ,CAACC,MAAM,GAAG,GAAG,EAAE;MACnD,OAAO;QACLV,GAAG;QACHU,MAAM,EAAED,QAAQ,CAACC,MAAM;QACvBqE,SAAS,EAAE,IAAI;QACfjE,OAAO,EAAE,oBAAoB;QAC7BF,IAAI,EAAEH,QAAQ,CAACG;MACjB,CAAC;IACH;;IAEA;IACA,OAAO;MACLZ,GAAG;MACHU,MAAM,EAAED,QAAQ,CAACC,MAAM;MACvBqE,SAAS,EAAE,KAAK;MAChBjE,OAAO,EAAE,4BAA4BL,QAAQ,CAACC,MAAM,IAAID,QAAQ,CAACmF,UAAU,EAAE;MAC7EhF,IAAI,EAAEH,QAAQ,CAACG;IACjB,CAAC;EACH,CAAC,CAAC,OAAON,KAAK,EAAE;IAAA,IAAAuF,gBAAA;IACd/F,OAAO,CAACQ,KAAK,CAAC,0BAA0BN,GAAG,GAAG,EAAEM,KAAK,CAAC;;IAEtD;IACA,IAAIA,KAAK,CAACwF,IAAI,KAAK,aAAa,EAAE;MAChC,OAAO;QACL9F,GAAG;QACHU,MAAM,EAAE,eAAe;QACvBqE,SAAS,EAAE,KAAK;QAChBb,aAAa,EAAE,KAAK;QACpBpD,OAAO,EAAE,qCAAqC;QAC9CR,KAAK,EAAEA,KAAK,CAACQ;MACf,CAAC;IACH;IAEA,OAAO;MACLd,GAAG;MACHU,MAAM,EAAE,EAAAmF,gBAAA,GAAAvF,KAAK,CAACG,QAAQ,cAAAoF,gBAAA,uBAAdA,gBAAA,CAAgBnF,MAAM,KAAI,OAAO;MACzCqE,SAAS,EAAE,KAAK;MAChBjE,OAAO,EAAE,UAAUR,KAAK,CAACQ,OAAO,EAAE;MAClCR,KAAK,EAAEA,KAAK,CAACQ;IACf,CAAC;EACH;AACF,CAAC;AAED,eAAe5B,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}